<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DotNetXtensions.Common</name>
    </assembly>
    <members>
        <member name="P:DotNetXtensions.ColorRGB.Luminance">
            <summary>
            http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
            Formula calculated here thanks to Brian Suda: http://24ways.org/2010/calculating-color-contrast/
            </summary>
        </member>
        <member name="P:DotNetXtensions.ColorRGB.YIC">
            <summary>
            https://en.wikipedia.org/wiki/YIQ
            </summary>
        </member>
        <member name="M:DotNetXtensions.ColorRGB.#ctor(System.String)">
            <summary>
            (Source: I (Nicholas Petersen) converted this over from a hodge podge of
            JavaScript code I had gotten from other sources and was using for some years. 
            This article was influential: https://24ways.org/2010/calculating-color-contrast/)
            </summary>
            <param name="hex"></param>
        </member>
        <member name="T:DotNetXtensions.Colour">
            <summary>
            Color structure (has similarities to the one used in System.Drawing). 
            The color structure is immutable and holds a 32-bit unsigned interger color value with 8 bits for each of the alpha, red, green and blue.
            </summary>
            <remarks>
                In libgd true color is represented as 32 bit signed integer. The sign bit is ignored and always zero.
                Also in libgd alpha = 0 means opaque while alpha = 0x7f means transparent. 
                This Color structure has alpha=0 means transparent and alpha = 0xff means opaque. 
                The reason behind the difference is that most .NET developers are familiar with Color structure in System.Drawing
                and also because in HTML alpha=0xff also means opaque. Since the target audience of this wrapper is most likely developing
                web application for ASP.NET 5 and/or a .NET developer familiar Color in system.Drawing, I choose to make it different than libgd 
                and have the library internally convert the alpha part.
            
                The above is only relevant in because of the following:
                1- There is a small loss in alpha resolution cause by libgd (it's 7 bits instead of 8 bits)
                2- When accessing image raw pointer, colors will not work like this structurce and will rather be libgd true color in case of truecolor image
                and color index in case of non true color images.
            </remarks>
        </member>
        <member name="P:DotNetXtensions.Colour.Argb">
            <summary>
            32-bit color value with 8 bits used for each of the components (aarrggbb)
            </summary>
        </member>
        <member name="P:DotNetXtensions.Colour.A">
            <summary>
            The Alpha component of the color. 0xff is fully opaque, 0x00 is fully transparent.
            </summary>
        </member>
        <member name="P:DotNetXtensions.Colour.R">
            <summary>
            The Red component of the color
            </summary>
        </member>
        <member name="P:DotNetXtensions.Colour.G">
            <summary>
            The green component of the color
            </summary>
        </member>
        <member name="P:DotNetXtensions.Colour.B">
            <summary>
            The blue component of the color
            </summary>
        </member>
        <member name="M:DotNetXtensions.Colour.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of Color
            </summary>
            <param name="argb">32-bit color value with 8 bits used for each of the components (aarrggbb)</param>
        </member>
        <member name="M:DotNetXtensions.Colour.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of Color
            </summary>
            <param name="a">alpha component</param>
            <param name="r">red component</param>
            <param name="g">green component</param>
            <param name="b">blue component</param>
        </member>
        <member name="M:DotNetXtensions.Colour.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of Color from red, green and blue. Alpha component is considered apaque (0xff).
            </summary>
            <param name="r">red component</param>
            <param name="g">green component</param>
            <param name="b">blue component</param>
        </member>
        <member name="M:DotNetXtensions.Colour.#ctor(System.Int64,System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of Color from red, green and blue. Alpha component is considered apaque (0xff).
            </summary>
            <param name="r">red component</param>
            <param name="g">green component</param>
            <param name="b">blue component</param>
        </member>
        <member name="M:DotNetXtensions.Colour.#ctor(System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Initializes a new instance of Color from red, green and blue. Alpha component is considered apaque (0xff).
            </summary>
            <param name="r">red component</param>
            <param name="g">green component</param>
            <param name="b">blue component</param>
        </member>
        <member name="M:DotNetXtensions.Colour.#ctor(System.String)">
            <summary>
            Initializes a new instance of color from a string.
            </summary>
            <param name="htmlColor">html color can be either known color name (such as "red", "yellow", "darkblue", etc), 
            "#aarrggbb" as in html (# is required), "#rrggbb" (# is required, alpha is considered ff) or #rgb </param>
        </member>
        <member name="M:DotNetXtensions.Colour.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Initializes the color from hue, saturation and brightness.
            </summary>
            <param name="hue">The angle in degrees around the axis of colors cylinder in the RGB color model. Valid values are from 0 inclusive to 360 exclusive.</param>
            <param name="saturation">The distance from the center of the cylinder. Valid values from 0 inclusive to 1 inclusive.</param>
            <param name="brightness">Brightness or lightness. Valid values from 0 inclusive to 1 inclusive.</param>
        </member>
        <member name="M:DotNetXtensions.Colour.Equals(System.Object)">
            <summary>
            Compares Color to another object.
            </summary>
            <param name="obj">object to compare.</param>
            <returns>True if obj is a Color object having the same value, false otherwise.</returns>
        </member>
        <member name="M:DotNetXtensions.Colour.GetHashCode">
            <summary>
            Gets hashcode of the color object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.Colour.Equals(DotNetXtensions.Colour)">
            <summary>
            Compares Color to another object.
            </summary>
            <param name="other">color to compare</param>
            <returns>True if the colors have the same value, false otherwise.</returns>
        </member>
        <member name="P:DotNetXtensions.Colour.Name">
            <summary>
            Color name such as "red", "green", "yellow", is the color is a known value, #aarrggbb otherwise.
            </summary>
        </member>
        <member name="M:DotNetXtensions.Colour.op_Equality(DotNetXtensions.Colour,DotNetXtensions.Colour)">
            <summary>
            compares 2 colors for equality
            </summary>
            <param name="c1"></param>
            <param name="c2"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.Colour.op_Inequality(DotNetXtensions.Colour,DotNetXtensions.Colour)">
            <summary>
            compares 2 colors for inquality.
            </summary>
            <param name="c1"></param>
            <param name="c2"></param>
            <returns></returns>
        </member>
        <member name="T:DotNetXtensions.ColourNameConverter">
            <summary>
            Helper class for converting color to string and vice versa
            </summary>
        </member>
        <member name="F:DotNetXtensions.ColourNameConverter.NameToColorDictionary">
            <summary>
            Dictionary for mapping color names to colors
            </summary>
        </member>
        <member name="F:DotNetXtensions.ColourNameConverter.ColorToNameDictionary">
            <summary>
            Dictionary to map colors to names
            </summary>
        </member>
        <member name="M:DotNetXtensions.ColourNameConverter.FromHtmlColor(System.String)">
            <summary>
            Using HTML color get the Color struct
            </summary>
            <param name="htmlColor">valid values are names like "red", "orange", "darkgreen", etc, or html formats "#aarrggbb", "#rrggbb" or "#rgb".</param>
            <returns></returns>
        </member>
        <member name="T:DotNetXtensions.Globalization.GeoNames">
            <summary>
            Class containing geographical and national information, currently world country names and state names.
            </summary>
        </member>
        <member name="F:DotNetXtensions.Globalization.GeoNames.Countries">
            <summary>
            Country names.
            </summary>
        </member>
        <member name="F:DotNetXtensions.Globalization.GeoNames.States">
            <summary>
            US and Canadian state names.
            </summary>
        </member>
        <member name="F:DotNetXtensions.Globalization.GeoNames.CountriesOrdered">
            <summary>
            Country names sorted. This is useful when conducting a binary search.
            </summary>
        </member>
        <member name="F:DotNetXtensions.Globalization.GeoNames.StatesOrdered">
            <summary>
            US and Canadian state names ordered. This is useful when conducting a binary search.
            </summary>
        </member>
        <member name="F:DotNetXtensions.Globalization.GeoNames.CountriesTopped">
            <summary>
            Country names with a few of the common countries many of us have to deal with on top.
            You can change these values (or simply never use this!) by calling SetCountriesTopped.
            </summary>
        </member>
        <member name="F:DotNetXtensions.Globalization.GeoNames.CountriesDictByFullName">
            <summary>
            A dictionary of country names <i>keyed by the full country name</i>, with the abbreviation as the value.
            So this allows one to lookup the abbreviation for a country when they already have the full country name.
            </summary>
        </member>
        <member name="F:DotNetXtensions.Globalization.GeoNames.StatesDictByFullName">
            <summary>
            A dictionary of state names <i>keyed by the full state name</i>, with the abbreviation as the value.
            So this allows one to lookup the abbreviation for a state when they already have the full state name.
            </summary>
        </member>
        <member name="F:DotNetXtensions.Globalization.GeoNames.CountriesDict">
            <summary>
            A dictionary of country names <i>keyed by the country abbreviation</i>, with the full country name as the value.
            So this allows one to lookup the abbreviation for a country when they already have the full name.
            <remarks>
            Information was initially based on: http://www.paladinsoftware.com/Generic/countries.htm (Nov 2013)
            </remarks>
            </summary>
        </member>
        <member name="F:DotNetXtensions.Globalization.GeoNames.StatesDict">
            <summary>
            A dictionary of state names <i>keyed by the country abbreviation</i>, with the full state name as the value.
            So this allows one to lookup the abbreviation for a state when they already have the full state name.
            </summary>
        </member>
        <member name="M:DotNetXtensions.Globalization.GeoNames.SetCountriesTopped(System.String[])">
            <summary>
            Set the CountriesTopped field with the input topCountries on top.
            Value gotten from GetCountriesWithTheseOnTop.
            </summary>
            <param name="topCountries">The names of countries (full names or abbreviations both work, even mixed) 
            you would like to be set on top in the CountriesTopped field.</param>
        </member>
        <member name="M:DotNetXtensions.Globalization.GeoNames.GetGeoNamesEnumsCode">
            <summary>
            Gets C# code generated from the current Countries and States 
            dictionaries for making them into enums.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.Globalization.Diacritics.ToAscii(System.Char)">
            <summary>
            If this char is a diacritic value, it is converted to a simple ascii value,
            else the same char is returned. MAX performance guaranteed! Including that
            simple ascii letter/numbers will immediately return on a single lesser than check.
            </summary>
            <param name="c">The char.</param>
        </member>
        <member name="M:DotNetXtensions.Globalization.Diacritics._ToAscii_DictLookup(System.Char)">
            <summary>
            Use DiacriticToAscii instead. This is for Testing purposes only (it uses a dictionary 
            lookup instead of the ~ 7 X faster array lookup).
            </summary>
            <param name="c">The char.</param>
        </member>
        <member name="M:DotNetXtensions.Globalization.Diacritics.ToAsciiString(System.String)">
            <summary>
            Converts any European type diacritics (see the 438 in the accompanying dictionary)
            in this string to regular ascii type chars. Heavy duty performance! Heavily geared towards
            cases where no conversion is needed. In those cases, there is nothing but a one 
            time zip through the string (checking each char if it's numerical value is greater
            than a constant value - higher than all ascii letter values). See accompanying times
            in this class to see what diacritics are handled.
            </summary>
        </member>
        <member name="M:DotNetXtensions.Globalization.Diacritics.AlternativeDeaccentString(System.String)">
            <summary>
            Convert accented characters to a non-accentered form using the .NET "ISO-8859-8" encoding.
            For test purposes (particularly for performance).
            
            http://stackoverflow.com/questions/249087/how-do-i-remove-diacritics-accents-from-a-string-in-net
            http://stackoverflow.com/a/2086575/264031
            </summary>
        </member>
        <member name="F:DotNetXtensions.Globalization.Diacritics.SourceDictionary">
            <summary>
            Started with information from here: http://personal-pages.lvc.edu/sayers/diacritic_table.html
            Would gladly have started from a more offical page, like on wikipedia, but this worked best.
            Grunt work sorting this was done. There's nothing stopping us from adding other values,
            though this list is quite nicely done. 
            <para/>
            Compromises were made for certain values that 
            don't have a clear ascii value, like the 'thorn' þ. Another big issue are letters that
            represent two chars (œ, ǽ ... ß to 's' instead of 'ss', etc). We made a critically important 
            decision to NOT make these into two. It is far better performance; much of what we have programmed
            here would be almost useless to adopt that model, and doesn't matter in scenarios
            where the question is more of a programmatic one where two sides of an equation are handled
            in house. For instance, a list of company names, if a user searches for a company and inserts
            a given diacritic, we convert that search query first, as well as all company names in place
            that they are compared. Surely, in other cases we would rather have it the other way, but 
            you would greatly loose in performance and simplicity for those scenarios, so may need
            to handle those few cases separately.
            </summary>
        </member>
        <member name="M:DotNetXtensions.Globalization.Diacritics._PrintoutDiacritics">
            <summary>
            Prints out our AsciiDiacriticsDictionary values in a sorted way that shows
            the decimal numeric values, etc.
            </summary>
        </member>
        <member name="M:DotNetXtensions.Globalization.Diacritics._ViewAllDiacriticsNotHandledByCompareOptionsIgnoreNonSpace">
            <summary>
            Great. After all this, found out there is already a native string comparison available that
            handles most of our diacritics. Here are the results (we've excepted the uppercase equivalents):
            <para />
            æ ǽ ĳ ŋ œ ß þ ŧ
            <para />
            Regardless, without having tested this, it is no doubt a much slower comparison to make
            as opposed to converting values beforehand.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.Globalization.Diacritics.PerfTest_DiacriticsMain">
            <summary>
            RESULTS:
            --- All following were for 100 million lookups total:
            DiacriticToAsciiDict:		~ 2220ms (2.2 seconds)
            DiacriticToAsciiSlower:	~ 578ms! (nearly 4 times faster [3.8] than dict lookup!!!)
            DiacriticToAscii:			~ 375ms! (6X faster than dict, and a whopping 35% faster than other array method
            											But not magnitudes faster than smaller array, so not necc. 
            											worth the extra memory needed . OTOHand, code is simpler)
            											Equal 1 million lookups every 3 ms
            </summary>
        </member>
        <member name="M:DotNetXtensions.Globalization.Diacritics.PerfTest_Loop(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="version">0 for dictionary, 1 for slower array if available, 
            2 for fast array lookup.</param>
            <param name="numhits">How many total hits tests to run.</param>
        </member>
        <member name="M:DotNetXtensions.Globalization.TimeZonesX.TZId(System.TimeZoneInfo)">
            <summary>
            Gets the first TZ Id value for this TimeZoneInfo. This is an indirection 
            call to DotNetXtensions.Time.GetTZValueFromWindowsTimeZoneId.
            </summary>
            <param name="tzi">TimeZoneInfo</param>
        </member>
        <member name="M:DotNetXtensions.Globalization.TimeZonesX.TZIdValues(System.TimeZoneInfo)">
            <summary>
            Gets the all TZ id values (often there is only one) for this TimeZoneInfo. 
            This is an indirection call to DotNetXtensions.Time.GetTZValuesFromWindowsTimeZoneId.
            </summary>
            <param name="tzi">TimeZoneInfo</param>
        </member>
        <member name="T:DotNetXtensions.Globalization.TZKeyValues">
            <summary>
            Note from 2018-04: I'm not happy how this was done, a lot was done for 
            perf concerns, because most tz keys didn't have a multi-value, so 
            stuff was done to not use a collection when only the singular 
            Value property was set. However, if I had the time I would totally
            fix go through and fix this up. We could keep the perf concern but
            either: 1) keep the type readonly, then even as a struct, would be 
            way better and remove problems, or 2) make an ExtraValues property,
            instead of as is done where it looks like `Values` which serves some
            kind of seemingly messed up multi-purpose and I'm not sure correctly.
            </summary>
        </member>
        <member name="T:DotNetXtensions.KV`2">
            <summary>
            A simple class based KeyValue pair type. The chief benefit
            over the framework's KeyValuePair struct type is that Key and
            Value are not readonly with KV. (And as an aside, how much nicer
            it would have been if the framework's struct had been named
            with the short and tidy "KV" instead.)
            </summary>
            <typeparam name="TKey">Type T, no constraints.</typeparam>
            <typeparam name="TValue">Type Y, no constraints.</typeparam>
        </member>
        <member name="P:DotNetXtensions.KV`2.Key">
            <summary>
            KV Key.
            </summary>
        </member>
        <member name="P:DotNetXtensions.KV`2.Value">
            <summary>
            KV Value.
            </summary>
        </member>
        <member name="T:DotNetXtensions.KV">
            <summary>
            A simple class based KeyValue pair type. The chief benefit
            over the framework's KeyValuePair struct type is that Key and
            Value are not readonly with KV. (And as an aside, how much nicer
            it would have been if the framework's struct had been named
            with the short and tidy "KV" instead.)
            </summary>
        </member>
        <member name="P:DotNetXtensions.KV.Key">
            <summary>
            KV Key.
            </summary>
        </member>
        <member name="P:DotNetXtensions.KV.Value">
            <summary>
            KV Value.
            </summary>
        </member>
        <member name="T:DotNetXtensions.BasicMimeType">
            <summary>
            An enum that contains many of the most common or basic mimetypes,
            thus the name <see cref="T:DotNetXtensions.BasicMimeType"/>. The purpose is certainly
            not to enumerate every possible mimetype, which would be impossible
            and unadvisable. But it is beneficial in many cases to have this, 
            because for instance, the numeric value of these allows them to be 
            categorized by their base types (all 'text/*' ones are 100s, 
            'image/*' ones are 400s, etc), and importantly, a "base" type for each
            main category existed when the sub-mimetype isn't one of these, i.e. 
            see <see cref="F:DotNetXtensions.BasicMimeType.text"/> or <see cref="F:DotNetXtensions.BasicMimeType.audio"/>.
            See <see cref="T:DotNetXtensions.BasicMimeTypesX"/> for functions for working with these and
            with mimetypes in general.
            </summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.text">
            <summary><![CDATA[text: >= 100 && < 400]]></summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.text_plain">
            <summary>text/plain</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.text_html">
            <summary>text/html</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.text_xml">
            <summary>text/xml, note there is also application/xml</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.image">
            <summary><![CDATA[image: >= 400 && < 500]]></summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.image_jpeg">
            <summary>image/jpeg</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.image_png">
            <summary>image/png</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.image_gif">
            <summary>image/gif</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.image_ico">
            <summary>image/x-icon</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.audio">
            <summary><![CDATA[audio: >= 500 && < 600]]></summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.audio_mp3">
            <summary>audio/mpeg (also? audio/mpeg3, audio/x-mpeg3), also: .mp1 .mp2 .mpg .mpeg</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.audio_aac">
            <summary>audio/aac</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.audio_aif">
            <summary>audio/aif</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.audio_mp4">
            <summary>audio/mp4, also: .m4a</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.audio_ogg">
            <summary>audio/ogg, also: .oga</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.audio_wav">
            <summary>audio/wav</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.audio_webm">
            <summary>audio/webm</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.audio_wma">
            <summary>audio/x-ms-wma</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.video">
            <summary><![CDATA[video: >= 600 && < 700]]></summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.video_mp4">
            <summary>video/mp4 (MPEG-4); also: .m4v</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.video_3gp">
            <summary>video/3gpp (3GP Mobile)</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.video_avi">
            <summary>video/x-msvideo (A/V Interleave)</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.video_flv">
            <summary>video/x-flv (Flash)</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.video_m3u8">
            <summary>video/x-mpegURL (iPhone Index)</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.video_mov">
            <summary>video/quicktime (QuickTime)</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.video_ogg">
            <summary>video/ogg, also: .ogv</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.video_ts">
            <summary>video/MP2T (iPhone Segment)</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.video_vimeo">
            <summary>video/vimeo</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.video_webm">
            <summary>video/webm</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.video_wmv">
            <summary>video/x-ms-wmv (Windows Media)</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.video_youtube">
            <summary>video/youtube</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.application">
            <summary><![CDATA[application: >= 700 && < 800]]></summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.application_octetstream">
            <summary>application/octet-stream</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.application_json">
            <summary>application/octet-stream</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.application_pdf">
            <summary>application/pdf</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.application_word">
            <summary>application/msword, application/vnd.openxmlformats-officedocument.wordprocessingml.document, also: .doc, .docx</summary>
        </member>
        <member name="F:DotNetXtensions.BasicMimeType.application_xml">
            <summary>application/xml, note there is also text/xml</summary>
        </member>
        <member name="T:DotNetXtensions.BasicMimeTypesX">
            <summary>
            A type for working with mimetypes.
            </summary>
        </member>
        <member name="M:DotNetXtensions.BasicMimeTypesX.IsEnclosureType(DotNetXtensions.BasicMimeType)">
            <summary>
            Returns true if linkType is other than none or html 
            (the reverse of linkType.IsWebPageOrNone()).
            </summary>
        </member>
        <member name="M:DotNetXtensions.BasicMimeTypesX.HasNoSubtype(DotNetXtensions.BasicMimeType)">
            <summary>
            Indicates if the given type is only one of the generic types
            without a subtype (doesn't include none). E.g. BasicMimeType.audio.
            Internally, the numbering system allows us to know this, in that any enum with a 100 value (v % 100 == 0)
            is set as a generic mime type.
            </summary>
        </member>
        <member name="M:DotNetXtensions.BasicMimeTypesX.IsTextOrNone(DotNetXtensions.BasicMimeType)">
            <summary>
            Is none or is any of the text types (lt 200);
            </summary>
        </member>
        <member name="M:DotNetXtensions.BasicMimeTypesX.ToMimeTypeString(DotNetXtensions.BasicMimeType)">
            <summary>
            Returns the official mimetype string value for this enum value, e.g. "text/html" for text_html.
            </summary>
            <param name="mimeType"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.BasicMimeTypesX.GetMimeTypeFromPathOrUrl(System.String)">
            <summary>
            Gets the extension of the input url or file path by using <see cref="T:DotNetXtensions.UriPathInfo"/>, 
            and then gets the corresponding mimetype, if any.
            </summary>
        </member>
        <member name="M:DotNetXtensions.BasicMimeTypesX.GetMimeTypeFromPathOrUrl(DotNetXtensions.BasicMimeType,System.String)">
            <summary>
            Gets the extension of the input url or file path by using <see cref="T:DotNetXtensions.UriPathInfo"/>, 
            and then gets the corresponding mimetype, if any. Indirection method for discoverability sake.
            </summary>
            <param name="path">Path or Url, absolute or relative or simply a single file name.</param>
            <param name="none">Ignore.</param>
        </member>
        <member name="M:DotNetXtensions.BasicMimeTypesX.GetMimeTypeFromFileExtension(System.String)">
            <summary>
            Determines the mimetype for this extension (e.g. "jpg" or "pdf"). Is case insensitive.
            Indirection method for discoverability sake.
            </summary>
            <param name="ext">Extension, such as "jpg". Must NOT have the period.</param>
        </member>
        <member name="M:DotNetXtensions.BasicMimeTypesX.GetMimeTypeFromFileExtension(DotNetXtensions.BasicMimeType,System.String)">
            <summary>
            Determines the mimetype for this extension (e.g. "jpg" or "pdf"). Is case insensitive.
            Indirection method for discoverability sake.
            </summary>
            <param name="ext">Extension, such as "jpg". Must NOT have the period.</param>
            <param name="none">Ignore</param>
        </member>
        <member name="M:DotNetXtensions.BasicMimeTypesX.GetMostQualifiedMimeType(DotNetXtensions.BasicMimeType,DotNetXtensions.BasicMimeType)">
            <summary>
            Gets the most qualified mime type, with the first input (<paramref name="primary"/>) overriding the
            secondary input.
            </summary>
            <param name="primary">The primary value.</param>
            <param name="secondary">A secondary mime type, which will only override the primary if it is more qualified.</param>
        </member>
        <member name="M:DotNetXtensions.BasicMimeTypesX.GetMimeTypeFromString(System.String,System.Boolean)">
            <summary>
            Attempts to get a <see cref="T:DotNetXtensions.BasicMimeType"/> match for the input mimetype string. Note that this dictionary contains
            generic versions of the major mimetypes (minus subtype), where only the first part of the mimetype 
            is specified. Thus a search on any of the following values: "image", "image/", or "image/null",
            will return the generic image type <see cref="F:DotNetXtensions.BasicMimeType.image"/>. 
            If the specific value is not found and <paramref name="allowGenericMatchOnNotFound"/> is true 
            (FALSE by default), then we will attempt to get only the generic part of the mimetype as just discussed
            (e.g. if input `"image/someunsualimagetype"` fails, we will lookup `"image/"`).
            </summary>
            <param name="mimeTypeStr">String mime type, see notes above.</param>
            <param name="allowGenericMatchOnNotFound">See notes above.</param>
        </member>
        <member name="M:DotNetXtensions.BasicMimeTypesX.GetMimeTypeFromString(DotNetXtensions.BasicMimeType,System.String,System.Boolean)">
            <summary>
            Attempts to get a <see cref="T:DotNetXtensions.BasicMimeType"/> match for the input mimetype string. Note that this dictionary contains
            generic versions of the major mimetypes (minus subtype), where only the first part of the mimetype 
            is specified. Thus a search on any of the following values: "image", "image/", or "image/null",
            will return the generic image type <see cref="F:DotNetXtensions.BasicMimeType.image"/>. 
            If the specific value is not found and <paramref name="allowGenericMatchOnNotFound"/> is true 
            (FALSE by default), then we will attempt to get only the generic part of the mimetype as just discussed
            (e.g. if input `"image/someunsualimagetype"` fails, we will lookup `"image/"`).
            </summary>
            <param name="mimeTypeStr">String mime type, see notes above.</param>
            <param name="allowGenericMatchOnNotFound">See notes above.</param>
            <param name="none">Ignore</param>
        </member>
        <member name="M:DotNetXtensions.TextFuncs.ClearXmlTags(System.String,System.Boolean)">
             <summary>
             A high performance function which, at its most basic, simply
             deletes all spans within the input string that begin and end with
             pointy brackets. If no pointy brackets exist within the string,
             then the only cost of this function was a single iteration through
             the string (with each character tested if it matches the left pointy bracket
             (&lt;), upon which the same string is returned. Otherwise, when left and
             right pointy bracket pairs are found, those sections are removed, while the rest
             of the inner text is simply copied into a StringBuilder. Note that there is
             no checking if start and end tags match (see following). This is due to the intended
             use case of this function: that is to be a very high
             performance, extremely low overhead way of (in the original use case)
             escaping any simple html tags that exist within RSS or ATOM feed tags such as
             the 'title' element. Both RSS and ATOM feeds allow simple
             (but escaped) html tags within their title element (and some other such elements), even though
             more often, the title tag will have no html content. Consider the following example:
            
             <example><code><![CDATA[
             XElement e = XElement.Parse("<title>Hello &lt;i&gt;world&lt;/i&gt;!</title>");
             XElement e2 = XElement.Parse("<title><![CDATA[Hello <i>world</i>!]]X</title>"); // note: we end the end CDATA gt bracket here with an 'X'
            
             string value = e.Value;   // Result: 'Hello <i>world</i>!'
             string value2 = e2.Value; // Result: 'Hello <i>world</i>!'
            
             bool eq = value == value2; // true
            
             // We showed this to help users recognize the use scenarios for this function,
             // that is, in the CDATA case as well, XElement ends up giving you the unescaped XML value,
             // which is then what this function works upon.
             // I.e. XElement's Value automatically unescapes the pointy brackets
            
             string plainTitleText = ClearAnyXmlTags(value); // result: "Hello world!"
             ]]></code></example>
            
             The point of ClearAnyXmlTags is *not* to validate or pick up invalid XML. Consider these examples:
             <example><code><![CDATA[
             string value1 = "Hello <world>!"		// "Hello !"
             string value2 = "He>llo <world>!"		// "He>llo !"
             string value3 = "Hello <em><strong>world</em><strong>!"		// "Hello world!"
            
             // value1:   does not have an end tag ('world' is seen as a tag), but it doesn't matter,
             // that is just removed since it is treated as a tag.
            
             // value2:   checking looks always first for a left pointy bracket and then a right, thus that first
             // (and invalid) left pointy is included. As we said, this function is not about validating anything...
            
             // value3:   notice how the em and strong tags are nested wrongly, but since every 'tag'
             // (actually just every left then right pointy pair) is removed, it doesn't matter
             ]]></code></example>
            
             A terrific use case scenario, and indeed what this was made for, is if one was consuming RSS or ATOM
             feeds from many, uncontrolled sources, and then resyndicating that content in a cleaner, new feed format,
             where one of the requirements was to get rid of html elements in title and tags and so forth.
             Another use case is for one of those readers themselves, where the title element, let's say, needs
             to be displayed as plain text. The goal in all of these scenarios is to catch all valid html type
             tags and simply dispense of them.
             </summary>
             <param name="value">Tag that may or may not have (typically simple) html or xml tags.</param>
             <param name="trim">True to trim.</param>
        </member>
        <member name="M:DotNetXtensions.TextFuncs.RemoveBrackets(System.String)">
            <summary>
            Removes brackets of type [] and (), and trims the result afterwards
            if they existed. In future more options need available here, like what
            brackets to remove. Make sure to trim value before sending in here.
            The goal of this is to be very performant for cases where no bracket 
            exists.
            </summary>
        </member>
        <member name="M:DotNetXtensions.TextFuncs.PascalToUnderscoreString(System.String,System.Nullable{System.Boolean})">
            <summary>
            Alters a pascal string (e.g. 'doSomethingCool') to an underscore string ('do_something_cool').
            </summary>
            <param name="val"></param>
            <param name="toLower">True to lowercase the final result, false to uppercase, null to return as is.</param>
        </member>
        <member name="M:DotNetXtensions.TextFuncs.ConvertNCarriageReturnsToRN(System.String)">
            <summary>
            Converts any loner "\n" carriage returns to the full "\r\n" version,
            but with a focus on best possible performance. NO allocations are made
            at all and the original string is returned if it has no loner \n's. 
            Otherwise is still very high performance
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:DotNetXtensions.TextFuncs.GetEmailRegex(System.Nullable{System.TimeSpan})">
            <summary>
            Sources:
            https://stackoverflow.com/a/45177249/264031
            https://github.com/Microsoft/referencesource/blob/master/System.ComponentModel.DataAnnotations/DataAnnotations/EmailAddressAttribute.cs
            </summary>
        </member>
        <member name="M:DotNetXtensions.UriPathInfo.GetExtFromUrl(System.String)">
            <summary>
            Old extension getter, was much simpler, had no notion of query string.
            It also had arbitrary limits, because it was designed for a particular 
            case, not general (like max ext length of 8, url chars had to be only
            ascii letter or digit, etc).
            Now use <see cref="F:DotNetXtensions.UriPathInfo.Extension"/>
            </summary>
        </member>
    </members>
</doc>
