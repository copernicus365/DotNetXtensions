using System;
using System.Threading;
using System.Threading.Tasks;

namespace DotNetXtensions
{
	/// <summary>
	/// Allows multiple (100s, 1000s, +) tasks to be instantiated and run 
	/// in a loop (etx) but while putting a throttled limit on how many can
	/// be started at once. This is quite simply done with a SemaphoreSlim
	/// object, which is really the star that makes this possible.
	/// </summary>
	public class ConcurrentTasksRunner : IDisposable
	{
		SemaphoreSlim sem;

		/// <summary>
		/// For diagnostic purposes: Disabling causes things to run without 
		/// any throttling of tasks being started up, which is the whole 
		/// purpose of this type. So set this to true to see how things would have been
		/// otherwise, but this allows one to keep the exact same test code. 
		/// </summary>
		public bool DisableSemaphore { get; set; }

		/// <summary>
		/// The CurrentCount of the internal SemaphoreSlim object
		/// ('the number of threads that will be allowed to enter the 
		/// SemaphoreSlim object').
		/// </summary>
		public int CurrentSemCount { get { return sem.CurrentCount; } }

		/// <summary>
		/// Set this Action in order to output diagnostic output of when 
		/// RunTask fires and completes new tasks. 
		/// string param: dianostic string to print.
		/// bool param: 'isComplete', false if starting task, true if task has just completed.
		/// </summary>
		public Action<string, bool> Print { get; set; }

		public int MaxSemCount { get { return concurrentTasksCount; } }
		int concurrentTasksCount;

		// --- CONSTRUCTOR ---

		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="concurrentTasksCount">
		/// Number of concurrent tasks that can be
		/// started up at once. Minimum is 1 (will be fixed if less than). This simply sets
		/// the internal SemaphoreSlim's initialCount value.
		/// </param>
		public ConcurrentTasksRunner(int concurrentTasksCount)
		{
			if(concurrentTasksCount < 1) throw new ArgumentOutOfRangeException("Minimum concurrentTasksCount is 1");
			this.concurrentTasksCount = concurrentTasksCount;
			sem = new SemaphoreSlim(concurrentTasksCount, concurrentTasksCount);
		}

		/// <summary>
		/// Runs a new task (Task.Run) on the given function, but ensures that 
		/// not more than a maximum number of calls can be made to this function 
		/// before further calls are throttled. This is quite simply by using
		/// a SemaphoreSlim that is called (Wait-ed) at the start of this function,
		/// and released in a finally block within the task function, after the given function 
		/// was finished (or after it threw an exception). 
		/// <para />
		/// This method returns a Task, but it is not async (so don't await it,
		/// Task.Run that generated it already starts it). The reason for the return
		/// is if you need to wait for a collection of tasks to finish before moving on,
		/// just save all the tasks in a list and call Task.WaitAll on them at the end of the
		/// loop.
		/// <para/>
		/// NOTE: We currently only have this one method, but in future could
		/// easily have many overloads that coorespond to some of the overloads offered
		/// by Task.Run (e.g. allowing task cancellation tokens, etc).
		/// </summary>
		/// <param name="function">Function to run as a task (Task.Run)</param>
		/// <param name="i">An index number. This can be helpful in diagnostics, especially
		/// considering these calls are usually made within a loop).</param>
		/// <param name="id">An id that can be used for identifying this id in the 
		/// diagnostic output.</param>
		/// <param name="cancellationToken">
		/// A cancellation token that should be used to cancel the work (else leave null).</param>
		/// <param name="print">Print action which will override the instance Print if set.</param>
		/// <returns>Returns the Task generated by Task.Run.</returns>
		public Task RunTask(
			Func<Task> function,
			CancellationToken? cancellationToken = null,
			int i = 0,
			string id = null,
			Action<string, bool> print = null)
		{
			if (!DisableSemaphore)
				sem.Wait(); //await sem.WaitAsync();
		
			Task task = Task.Run(async () => {
				try {
					_print(false, i, id, print);
					await function();
				} finally {
					if (!DisableSemaphore)
						sem.Release();
					_print(true, i, id, print);
				}
			}, cancellationToken ?? default(CancellationToken));

			//task.ContinueWith(t => {
			//	if (!DisableSemaphore)
			//		sem.Release();
			//	_print(true, i, id, print);
			//});

			return task;
		}

		/// <summary>
		/// See overload.
		/// </summary>
		public Task<TResult> RunTask<TResult>(
			Func<Task<TResult>> function,
			CancellationToken? cancellationToken = null,
			int i = 0,
			string id = null,
			Action<string, bool> print = null)
		{
			if (!DisableSemaphore)
				sem.Wait();

			Task<TResult> task = Task.Run(async () => {
				try {
				_print(false, i, id, print);
				return await function();
				}
				finally {
					if (!DisableSemaphore)
						sem.Release();
					_print(true, i, id, print);
				}
			}, cancellationToken ?? default(CancellationToken));

			//task.ContinueWith(t => {
			//	if (!DisableSemaphore)
			//		sem.Release();
			//	_print(true, i, id, print);
			//});

			return task;
		}

		void _print(bool end, int i, string id, Action<string, bool> print)
		{
			if (print == null)
				print = Print;
			if (print != null)
				print($"{(end ? "Finished" : "Started ")} Run.Task[{i}{(id == null ? null : "--" + id)}] (thdId: {Thread.CurrentThread.ManagedThreadId}, semCnt: {sem.CurrentCount})", end);
		}

		public void Dispose()
		{
			if(sem != null)
				sem.Dispose();
		}

	}
}
