<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DotNetXtensions</name>
    </assembly>
    <members>
        <member name="T:DotNetXtensions.ComparerX`1">
            <summary>
            Class useful for being able to send in a simple
            Func that acts as the comparer for cases when a 
            full Comparer (a class!) is requested, as is the 
            case for instance with Array and many other CLR types.
            </summary>
            <typeparam name="T">Type.</typeparam>
        </member>
        <member name="P:DotNetXtensions.ComparerX`1.DefaultComparer">
            <summary>
            Gets the default comparer of type T if it implements
            IComparable[T], but if not, it does NOT throw an exception 
            and simply returns null (before calling Comparer[T].Default.Compare, we first 
            check if the Type implements the interface). This value is CACHED on the first 
            static call (whether or not it implements the interface) for utmost performance.
            </summary>
        </member>
        <member name="P:DotNetXtensions.ComparerX`1.DefaultEqualityComparer">
            <summary>
            Gets the default EqualityComparer of type T if it implements
            IEquatable[T] OR if it only implements IComparable[T], in which case we use that
            to test for equality (if equals 0). But if neither of these is true, it does NOT throw an exception 
            and simply returns null (before calling EqualityComparer[T].Default.Equals, we first 
            check if the Type implements the interface). This value is CACHED on the first 
            static call (whether or not it implements the interfaces) for utmost performance.
            </summary>
        </member>
        <member name="M:DotNetXtensions.ComparerX`1.#ctor(System.Func{`0,`0,System.Int32},System.Func{`0,System.Int32})">
            <summary>
            Constructor. This is what is helpful, just 
            say: 
            <code>new ComparerX(/*your func here, e.g.: s => s == "cool" */)</code>.
            </summary>
            <param name="comparer">Comparer Func.</param>
            <param name="getHash"></param>
        </member>
        <member name="M:DotNetXtensions.ComparerX`1.Compare(`0,`0)">
            <summary>
            Compare function that simply calls the function 
            sent in to the constructor.
            </summary>
            <param name="a">A.</param>
            <param name="b">B.</param>
            <returns>Standard.</returns>
        </member>
        <member name="M:DotNetXtensions.ComparerX`2.#ctor(System.Func{`0,`1},System.Func{`1,`1,System.Int32},System.Func{`1,System.Int32},System.Boolean)">
            <summary>
            Constructor. This is what is helpful, just 
            say: 
            <code>new ComparerX(/*your func here, e.g.: s => s == "cool" */)</code>.
            </summary>
            <param name="keySelector"></param>
            <param name="comparer">Comparer Func.</param>
            <param name="getHash"></param>
            <param name="reverse"></param>
        </member>
        <member name="M:DotNetXtensions.ComparerX`2.Compare(`0,`0)">
            <summary>
            Compare function that simply calls the function 
            sent in to the constructor.
            </summary>
            <param name="a">A.</param>
            <param name="b">B.</param>
            <returns>Standard.</returns>
        </member>
        <member name="T:DotNetXtensions.ComparisonComparer`1">
            <summary>
            Wraps a generic System.Comparison[T] delegate in an IComparer to make it easy 
            to use a lambda expression for methods that take an IComparer or IComparer T.
            Source: http://www.velir.com/blog/index.php/2011/02/17/ilistt-sorting-a-better-way/
            </summary>
        </member>
        <member name="M:DotNetXtensions.ComparisonComparerZ.ToIComparer``1(System.Comparison{``0})">
            <summary>
            Converts (wraps) the input Comparison[T] into a ComparisonComparer which 
            implements IComparer[T] and IComparer, interfaces which are often required
            when a Comparison[T] is not accepted.
            </summary>
        </member>
        <member name="T:DotNetXtensions.IStringSerializable">
            <summary>
            For types that need to custom serialize to and from a string and that can
            have a public parameterless constructor (new()), all you have to do is implement
            IStringSerializable on that type and this converter will suddenly work for 
            Json serialization. The nice thing about IStringSerializable is, if indeed your custom
            type already is serializing / deserializing to and from a string, then that logic can be
            baked quite apart from anything related to Json, or to a given Json library or other serializer.
            For instance, our "Colour" type (a struct) can implement this interface without necessarily now
            having anything to say or do with Json.
            </summary>
        </member>
        <member name="T:DotNetXtensions.Result">
            <summary>
            A general purpose "Result" type, which can be used
            to return Success, a Message, optionally a Count, etc.
            </summary>
        </member>
        <member name="T:DotNetXtensions.Result`1">
            <summary>
            A general purpose "Result" type which combines a "Value" of a generic
            type. This can can be used to return Success, a Message, optionally a Count, 
            and finally a Value of specified type.
            </summary>
        </member>
        <member name="T:DotNetXtensions.SResult">
            <summary>
            A *struct* based Result type ('S' in 'SResult' if for 'struct'), containg three fields: 
            A boolean Success value, a Message, and a Count. Consider this an option
            when you want *very low overhead (a struct)*, and might have otherwise used a KeyValuePair,
            which <see cref="T:DotNetXtensions.SResult"/> is much more user-friendly than, when used for this purpose.
            Consider <see cref="T:DotNetXtensions.Result"/> for a fuller optioned class based alterantive.
            </summary>
        </member>
        <member name="T:DotNetXtensions.SResult`1">
            <summary>
            A *struct* based Result type ('S' in 'SResult' if for 'struct'), containg four fields: 
            A boolean Success value, a Message, a Count, and the return value <typeparamref name="TResult"/>. 
            Consider this an option when you want *very low overhead (a struct)*, and might have otherwise 
            used a KeyValuePair. Consider <see cref="T:DotNetXtensions.Result`1"/> for a fuller optioned class based alterantive.
            </summary>
        </member>
        <member name="T:DotNetXtensions.XArray">
            <summary>
            Extension methods for arrays.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XArray.BinarySearch``1(``0[],``0)">
            <summary>
            Searches this array for the specified item using a rapid binary chop 
            search, which presumes that this array is sorted (the search will fail if it is not).
            The default IComparable&lt;T&gt; generic interface is implemented by each element 
            of this array type in comparing items.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XArray.IndexOfAll``1(``0[],``0)">
            <summary>
            Returns the index positions of all occurences of <paramref name="value"/>
            that are found in this array.
            <example><code>
            <![CDATA[
            int[] ints = { 66, 95, 32, 120, 66, 89, 66, 32 };
            
            int[] indexes = ints.IndexOfAll(66); // indexes = { 0, 4, 6 }
            ]]></code></example>
            </summary>
            <typeparam name="T">This type.</typeparam>
            <param name="arr">This array.</param>
            <param name="value">The value (i.e. array element) to search for.</param>
            <returns>The index positions of all occurences of <paramref name="value"/>,
            or an empty integer array (not a null array).</returns>
        </member>
        <member name="M:DotNetXtensions.XArray.LastIndexOf``1(``0[],``0)">
            <summary>
            Searches for the specified object and returns the index of the last ocurrence
            in this array, or -1 if it is not located.
            <example><code>
            <![CDATA[
            int[] years = { 1912, 2009, 1999, 1017, 2009, 1278, 1953 };
            
            int index = years.LastIndexOf(2009); // index == 4
            ]]></code></example>
            </summary>
            <typeparam name="T">The specified type.</typeparam>
            <param name="arr">This array.</param>
            <param name="value">The object to locate in this array</param>
            <returns>The index of the located object, or -1 if it is not found.</returns>
        </member>
        <member name="M:DotNetXtensions.XArray.LastIndexOf``1(``0[],``0,System.Int32)">
            <summary>
            Searches for the specified object and returns the index of the last ocurrence
            in the specified range of this array, or -1 if it is not located.
            </summary>
            <typeparam name="T">The specified type.</typeparam>
            <param name="arr">This array.</param>
            <param name="value">The object to locate in this array</param>
            <param name="start">The zero-based starting index of the backward search.</param>
            <returns>The index of the located object, or -1 if it is not found.</returns>
        </member>
        <member name="M:DotNetXtensions.XArray.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
            <summary>
            Searches for the specified object and returns the index of the last ocurrence
            in the specified range of this array, or -1 if it is not located.
            </summary>
            <typeparam name="T">The specified type.</typeparam>
            <param name="arr">This array.</param>
            <param name="value">The object to locate in this array</param>
            <param name="start">The zero-based starting index of the backward search.</param>
            <param name="length">The number of elements to search on following start.</param>
            <returns>The index of the located object, or -1 if it is not found.</returns>
        </member>
        <member name="M:DotNetXtensions.XArray.LastIndexOf(System.Array,System.Object)">
            <summary>
            Searches for the specified object and returns the index of the last ocurrence
            in this array, or -1 if it is not located.
            </summary>
            <param name="arr">This array.</param>
            <param name="value">The object to locate in this array</param>
            <returns>The index of the located object, or -1 if it is not found.</returns>
        </member>
        <member name="M:DotNetXtensions.XArray.LastIndexOf(System.Array,System.Object,System.Int32)">
            <summary>
            Searches for the specified object and returns the index of the last ocurrence
            in the specified range of this array, or -1 if it is not located.
            </summary>
            <param name="arr">This array.</param>
            <param name="value">The object to locate in this array</param>
            <param name="start">The zero-based starting index of the backward search.</param>
            <returns>The index of the located object, or -1 if it is not found.</returns>
        </member>
        <member name="M:DotNetXtensions.XArray.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
            <summary>
            Searches for the specified object and returns the index of the last ocurrence
            in the specified range of this array, or -1 if it is not located.
            </summary>
            <param name="arr">This array.</param>
            <param name="value">The object to locate in this array</param>
            <param name="start">The zero-based starting index of the backward search.</param>
            <param name="length">The number of elements to search on following start.</param>
            <returns>The index of the located object, or -1 if it is not found.</returns>
        </member>
        <member name="M:DotNetXtensions.XArray.IndexOfSequence``1(``0[],``0[])">
            <summary>
            Returns the index position where the find sequence is found
            within this array.
            <example><code>
            <![CDATA[
            byte[] ints1 = { 66, 95, 32, 120, 66, 89, 66, 32 };
            
            int index = ints1.IndexOfSequence(new byte[] { 32, 120, 66 }); // index == 2
            ]]>
            </code></example>
            </summary>
            <typeparam name="T">The sequence type.</typeparam>
            <param name="srcArray">The source array to search on.</param>
            <param name="findSeq">The sequence to search for.</param>
            <returns>The index of the find, or -1 if it is not found.</returns>
        </member>
        <member name="M:DotNetXtensions.XArray.IndexOfSequence``1(``0[],``0[],System.Int32)">
            <summary>
            Returns the index position where the find sequence is found
            within the specified range of this array.
            </summary>
            <typeparam name="T">The sequence type.</typeparam>
            <param name="srcArray">The source array to search on.</param>
            <param name="findSeq">The sequence to search for.</param>
            <param name="start">The zero based starting index.</param>
            <returns>The index of the find, or -1 if it is not found.</returns>
        </member>
        <member name="M:DotNetXtensions.XArray.IndexOfSequence``1(``0[],``0[],System.Int32,System.Int32)">
            <summary>
            Returns the index position where the find sequence is found
            within the specified range of this array.
            </summary>
            <typeparam name="T">The sequence type.</typeparam>
            <param name="srcArray">The source array to search on.</param>
            <param name="findSeq">The sequence to search for.</param>
            <param name="start">The zero based starting index of the search.</param>
            <param name="length">The maximum number of items to search following start.</param>
            <returns>The index of the find, or -1 if it is not found.</returns>
        </member>
        <member name="M:DotNetXtensions.XArray.RemoveSequentialValues``1(``0[],``0,System.Boolean)">
            <summary>
            See overload.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XArray.RemoveSequentialValues``1(System.Collections.Generic.IEnumerable{``0},``0,System.Boolean)">
            <summary>
            Trims any occurences of the specified duplicate value T to only one (1) occurence.
            Optionally trims the beginning and end of this value from the return result.
            </summary>
            <typeparam name="T">Type</typeparam>
            <param name="arr">Array</param>
            <param name="dup">Duplicate value to trim to one when two or more occur in the sequence.</param>
            <param name="trimEnds">True to trim the end result of the duplicate value if occuring.</param>
        </member>
        <member name="M:DotNetXtensions.XArray.ReverseArray``1(``0[])">
            <summary>
            Reverses the sequence of elements in this array.
            <example><code>
            <![CDATA[
            string[] liftoff = { "ten", "nine", "eight", "seven" };
            
            liftoff.ReverseArray();  // liftoff == { "seven", "eight", "nine", "ten" }
            ]]></code></example>
            <example><code>
            <![CDATA[
            int[] years = { 1912, 1847, 1999, 1017, 2009, 1278, 1953 };
            
            int[] sortedYearsReversed = years.Copy().Sort().ReverseArray();
            // sortedYearsReversed == { 2009, 1999, 1953, 1912, 1847, 1278, 1017 }
            
            // Note that by including "Copy()" in "years.Copy()...", the original array "years"
            // remains unaltered, while the new (and desired) sequence gets returned.
            ]]></code></example>
            </summary>
            <param name="arr">This array.</param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.XArray.ReverseArray``1(``0[],System.Int32)">
            <summary>
            Reverses the sequence of elements in the specified range of this array.
            </summary>
            <param name="arr">This array.</param>
            <param name="start">The starting index at which to begin.</param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.XArray.ReverseArray``1(``0[],System.Int32,System.Int32)">
            <summary>
            Reverses the sequence of elements in the specified range of this array.
            </summary>
            <param name="arr">This array.</param>
            <param name="start">The starting index at which to begin.</param>
            <param name="length">The number of elements to reverse following start.</param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.XArray.SequenceIsEqual(System.Byte[],System.Byte[])">
            <summary>
            Compares this array with <paramref name="comparisonArray"/> by iterating 
            through each item to see if they are equivalent.
            <example><code>
            <![CDATA[
            byte[] seq1 = { 120, 93, 248 };
            
            byte[] seq2 = { 120, 93, 248 };
            
            bool isEqual = seq1.SequenceIsEqual(seq2);  // isEqual == true
            ]]></code></example>
            </summary>
            <param name="srcArray">This array.</param>
            <param name="comparisonArray">The array to compare.</param>
            <returns>The start index of the found sequence, or -1 if it is not found.</returns>
        </member>
        <member name="M:DotNetXtensions.XArray.SequenceIsEqual(System.Char[],System.Char[])">
            <summary>
            Compares this array with <paramref name="comparisonArray"/> by iterating 
            through each item to see if they are equivalent.
            </summary>
            <param name="srcArray">This array.</param>
            <param name="comparisonArray">The array to compare.</param>
            <returns>The start index of the found sequence, or -1 if it is not found.</returns>
        </member>
        <member name="M:DotNetXtensions.XArray.SequenceIsEqual(System.Int16[],System.Int16[])">
            <summary>
            Compares this array with <paramref name="comparisonArray"/> by iterating 
            through each item to see if they are equivalent.
            </summary>
            <param name="srcArray">This array.</param>
            <param name="comparisonArray">The array to compare.</param>
            <returns>The start index of the found sequence, or -1 if it is not found.</returns>
        </member>
        <member name="M:DotNetXtensions.XArray.SequenceIsEqual(System.Int32[],System.Int32[])">
            <summary>
            Compares this array with <paramref name="comparisonArray"/> by iterating 
            through each item to see if they are equivalent.
            </summary>
            <param name="srcArray">This array.</param>
            <param name="comparisonArray">The array to compare.</param>
            <returns>The start index of the found sequence, or -1 if it is not found.</returns>
        </member>
        <member name="M:DotNetXtensions.XArray.SequenceIsEqual(System.Int64[],System.Int64[])">
            <summary>
            Compares this array with <paramref name="comparisonArray"/> by iterating 
            through each item to see if they are equivalent.
            </summary>
            <param name="srcArray">This array.</param>
            <param name="comparisonArray">The array to compare.</param>
            <returns>The start index of the found sequence, or -1 if it is not found.</returns>
        </member>
        <member name="M:DotNetXtensions.XArray.SequenceIsEqual(System.Double[],System.Double[])">
            <summary>
            Compares this array with <paramref name="comparisonArray"/> by iterating 
            through each item to see if they are equivalent.
            </summary>
            <param name="srcArray">This array.</param>
            <param name="comparisonArray">The array to compare.</param>
            <returns>The start index of the found sequence, or -1 if it is not found.</returns>
        </member>
        <member name="M:DotNetXtensions.XArray.SequenceIsEqual(System.Decimal[],System.Decimal[])">
            <summary>
            Compares this array with <paramref name="comparisonArray"/> by iterating 
            through each item to see if they are equivalent.
            </summary>
            <param name="srcArray">This array.</param>
            <param name="comparisonArray">The array to compare.</param>
            <returns>The start index of the found sequence, or -1 if it is not found.</returns>
        </member>
        <member name="M:DotNetXtensions.XArray.SequenceIsEqual(System.String[],System.String[])">
            <summary>
            Compares this array with <paramref name="comparisonArray"/> by iterating 
            through each item to see if they are equivalent.
            </summary>
            <param name="srcArray">This array.</param>
            <param name="comparisonArray">The array to compare.</param>
            <returns>The start index of the found sequence, or -1 if it is not found.</returns>
        </member>
        <member name="M:DotNetXtensions.XArray.SequenceIsEqual``1(``0[],``0[])">
            <summary>
            Compares this array with <paramref name="comparisonArray"/> by iterating 
            through each item to see if they are equivalent.
            <example><code>
            <![CDATA[
            byte[] seq1 = { 120, 93, 248 };
            
            byte[] seq2 = { 120, 93, 248 };
            
            bool isEqual = seq1.SequenceIsEqual(seq2);  // isEqual == true
            ]]></code></example>
            </summary>
            <param name="srcArray">This array.</param>
            <param name="comparisonArray">The array to compare.</param>
            <returns>The start index of the found sequence, or -1 if it is not found.</returns>
        </member>
        <member name="M:DotNetXtensions.XArray.Sort``1(``0[])">
            <summary>
            Sorts the elements in this array using the default IComparable&lt;T&gt;
            implementation.<para/><para/>
            <example><code>
            <![CDATA[
            int[] years = { 1912, 1847, 1999, 1017, 2009, 1278, 1953 };
            
            int[] sortedYears = years.Copy().Sort();
            // sortedYears == { 1017, 1278, 1847, 1912, 1953, 1999, 2009 }
            
            // Note that by including "Copy()" in "years.Copy()...", the original array "years"
            // remains unaltered, while the new (and desired) sequence gets returned.
            ]]></code></example>
            <example><code>
            <![CDATA[
            string[] names = "Fernando, Alice, Zachery, Joe, Niel, Robert, Sandra".RxSplit(@"\s*,\s*");
            // names == { "Fernando", "Alice", "Zachery", "Joe", "Niel", "Robert", "Sandra" }
            
            string[] sorted = names.Copy().Sort();
            // sorted == { "Alice", "Fernando", "Joe", "Niel", "Robert", "Sandra", "Zachery" }
            
            // * RxSplit() is a DotNetExtensions extension method.
            ]]></code></example>
            </summary>
            <typeparam name="T">The specified type.</typeparam>
            <param name="arr">This array.</param>
        </member>
        <member name="M:DotNetXtensions.XArray.Sort``1(``0[],System.Comparison{``0})">
            <summary>
            Sorts the elements in this array using the specified Comparison&lt;T&gt;.
            </summary>
            <typeparam name="T">The specified type.</typeparam>
            <param name="arr">This array.</param>
            <param name="comparison">The Comparison&lt;T&gt; to use when comparing elements.</param>
        </member>
        <member name="M:DotNetXtensions.XArray.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the elements in this array using the specified IComparer&lt;T&gt; 
            interface.
            <example><code>
            <![CDATA[
            // To see the full declaration of this IComparer<T>, see the full entry of this method overload)
            PresidentsComparer presCompare = new PresidentsComparer();
            
            string[] somePresidents = { "Truman", "Garfield", "Clinton", "Lincoln", "Reagan", "Roosevelt" };
            
            string[] alphaSorted = somePresidents.Copy().Sort();
            // A regular sort:  alphaSorted == { Clinton,Garfield,Lincoln,Reagan,Roosevelt,Truman }
            
            string[] historySorted = somePresidents.Copy().Sort(presCompare);
            // Custom comparer sorted:  historySorted == { Lincoln,Garfield,Roosevelt,Truman,Reagan,Clinton }
            ]]>
            </code></example>
            </summary>
            <example><code>
            <![CDATA[
            // A simple comparer that allows US presidents to be historically sorted
            public class PresidentsComparer : IComparer<string>
            {
               public string[] presidents;
            
               // CONSTRUCTOR:
               public PresidentsComparer()
               {
                  presidents = new string[] { 
                     "Washington",  "Adams",  "Jefferson",  "Madison", "Monroe",  "Adams II",  
                     "Jackson",  "Van Buren", "Harrison",  "Tyler",  "Polk",  "Taylor", "Fillmore",  
                     "Pierce",  "Buchanan",  "Lincoln", "Johnson", "Grant", "Hayes", "Garfield",  
                     "Arthur",  "Cleveland",  "Harrison",  "Cleveland II", "McKinley", "Roosevelt", 
                     "Taft",  "Wilson", "Harding", "Coolidge", "Hoover", "Roosevelt", "Truman",  
                     "Eisenhower",  "Kennedy",  "Johnson", "Nixon",  "Ford",  "Carter", "Reagan",  
                     "Bush",  "Clinton",  "Bush II",  "Obama" };
               }
            
            public int Compare(string pres1, string pres2)
            {
               int a = presidents.IndexOf(pres1);
               int b = presidents.IndexOf(pres2);
            
               if (a < 0 || b < 0) throw new Exception("The person you entered was never a president!");
            
               if (a < b) return -1;
            
               else if (a > b) return 1;
            
               else if (a == b) return 0;
            
               throw new Exception("We shouldn't get here.");
            }
            ]]></code></example>
            <typeparam name="T">The specified type.</typeparam>
            <param name="arr">This array.</param>
            <param name="comparer">The IComparer&lt;T&gt; implementation to use when 
            comparing elements, or null to use the default implementation.</param>
        </member>
        <member name="M:DotNetXtensions.XArray.Sort``1(``0[],System.Int32,System.Int32)">
            <summary>
            Sorts the elements in the specified range of this array using the default 
            IComparable&lt;T&gt; implementation.
            </summary>
            <typeparam name="T">The specified type.</typeparam>
            <param name="arr">This array.</param>
            <param name="index">The starting index of the range to sort.</param>
            <param name="length">The number of elements to sort in the specified range.</param>
        </member>
        <member name="M:DotNetXtensions.XArray.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the elements in the specified range of this array using the specified 
            IComparer&lt;T&gt; interface.
            </summary>
            <typeparam name="T">The specified type.</typeparam>
            <param name="arr">This array.</param>
            <param name="index">The starting index of the range to sort.</param>
            <param name="length">The number of elements to sort in the specified range.</param>
            <param name="comparer">The IComparer&lt;T&gt; implementation to use when 
            comparing elements, or null to use the default implementation.</param>
        </member>
        <member name="M:DotNetXtensions.XArray.Sort(System.Array)">
            <summary>
            Sorts the elements in this array using the default IComparable
            implementation.
            </summary>
            <param name="arr">This array.</param>
        </member>
        <member name="M:DotNetXtensions.XArray.Sort(System.Array,System.Collections.IComparer)">
            <summary>
            Sorts the elements in this array using the specified IComparer.
            </summary>
            <param name="arr">This array.</param>
            <param name="comparer">The IComparer implementation to use when 
            comparing elements, or null to use the default implementation.</param>
        </member>
        <member name="M:DotNetXtensions.XArray.Sort(System.Array,System.Int32,System.Int32)">
            <summary>
            Sorts the elements in the specified range of this array using the default 
            IComparable implementation.
            </summary>
            <param name="arr">This array.</param>
            <param name="index">The starting index of the range to sort.</param>
            <param name="length">The number of elements to sort in the specified range.</param>
        </member>
        <member name="M:DotNetXtensions.XArray.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
            <summary>
            Sorts the elements in the specified range of this array using the specified 
            IComparer.
            </summary>
            <param name="arr">This array.</param>
            <param name="index">The starting index of the range to sort.</param>
            <param name="length">The number of elements to sort in the specified range.</param>
            <param name="comparer">The IComparer implementation to use when 
            comparing elements, or null to use the default implementation.</param>
        </member>
        <member name="M:DotNetXtensions.XArray.Sort``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
            <summary>
            Sorts an IList T in place.
            Source: http://www.velir.com/blog/index.php/2011/02/17/ilistt-sorting-a-better-way/
            </summary>
        </member>
        <member name="M:DotNetXtensions.XArray.SortPair``2(``0[],``1[])">
            <summary>
            Sorts this array (<paramref name="baseArray"/>, often called the <i>keys</i> array) 
            while sorting a paired array (<paramref name="pairedArray"/>, which is often called 
            the <i>items</i> array) in tandem with it.  The <paramref name="baseArray"/> is what 
            determines the sorted order which is sorted by the default IComparable&lt;T&gt;
            interface.  Both arrays should be of the same length.
            <example><code>
            <![CDATA[
            int[] familyAges = { 33, 6, 3, 32 };
            
            string[] familyNames = { "Todd", "Cloey", "Joey", "Teressa" };
            
            familyAges.SortPair(familyNames);
            
            // To see results: 
            string family = "";
            for (int i = 0; i < familyAges.Length; i++)
               family += familyNames[i] + " - " + familyAges[i] + "; ";
            
            // family == "Joey - 3; Cloey - 6; Teressa - 32; Todd - 33; "
            ]]></code></example><para />
            </summary>
            <typeparam name="TBase">The base array type.</typeparam>
            <typeparam name="TPair">The paired array type.</typeparam>
            <param name="baseArray">The base array which determines the sorted 
            order of the pair.</param>
            <param name="pairedArray">The paired array which will be sorted in tandem 
            with <paramref name="baseArray"/>.</param>
        </member>
        <member name="M:DotNetXtensions.XArray.SortPair``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts this array (<paramref name="baseArray"/>, often called the <i>keys</i> array) 
            while sorting a paired array (<paramref name="pairedArray"/>, which is often called 
            the <i>items</i> array) in tandem with it.  The <paramref name="baseArray"/> is what 
            determines the sorted order which is sorted by the specified IComparer&lt;T&gt; 
            interface.  Both arrays should be of the same length.
            <example><code>
            <![CDATA[
            // To see the full declaration of this IComparer<T>, see the full entry of this method overload)
            PresidentsComparer presCompare = new PresidentsComparer();
            
            string[] somePresidents = { "Clinton", "Garfield", "Lincoln", "Reagan", "Roosevelt", "Truman" };
            
            int[] inaugYear = { 1993, 1881, 1861, 1981, 1933, 1945 };
            
            somePresidents.SortPair(inaugYear, presCompare);
            
            // Results:
            string results = "";
            for (int i = 0; i < somePresidents.Length; i++)
               results += "{0}-{1}; ".FormatX(somePresidents[i], inaugYear[i]);
            // results == "Lincoln-1861; Garfield-1881; Roosevelt-1933; Truman-1945; Reagan-1981; Clinton-1993; "
            
            // * FormatX() is a DotNetExtensions extension method
            ]]>
            </code></example>
            </summary>
            <example><code>
            <![CDATA[
            // A simple comparer that allows US presidents to be historically sorted
            public class PresidentsComparer : IComparer<string>
            {
               public string[] presidents;
            
               // CONSTRUCTOR:
               public PresidentsComparer()
               {
                  presidents = new string[] { 
                     "Washington",  "Adams",  "Jefferson",  "Madison", "Monroe",  "Adams II",  
                     "Jackson",  "Van Buren", "Harrison",  "Tyler",  "Polk",  "Taylor", "Fillmore",  
                     "Pierce",  "Buchanan",  "Lincoln", "Johnson", "Grant", "Hayes", "Garfield",  
                     "Arthur",  "Cleveland",  "Harrison",  "Cleveland II", "McKinley", "Roosevelt", 
                     "Taft",  "Wilson", "Harding", "Coolidge", "Hoover", "Roosevelt", "Truman",  
                     "Eisenhower",  "Kennedy",  "Johnson", "Nixon",  "Ford",  "Carter", "Reagan",  
                     "Bush",  "Clinton",  "Bush II",  "Obama" };
               }
            
            public int Compare(string pres1, string pres2)
            {
               int a = presidents.IndexOf(pres1);
               int b = presidents.IndexOf(pres2);
            
               if (a < 0 || b < 0) throw new Exception("The person you entered was never a president!");
            
               if (a < b) return -1;
            
               else if (a > b) return 1;
            
               else if (a == b) return 0;
            
               throw new Exception("We shouldn't get here.");
            }
            ]]></code></example>
            <typeparam name="TBase">The base array type.</typeparam>
            <typeparam name="TPair">The paired array type.</typeparam>
            <param name="baseArray">The base array which determines the sorted 
            order of the pair.</param>
            <param name="pairedArray">The paired array which will be sorted in tandem 
            with <paramref name="baseArray"/>.</param>
            <param name="comparer">The IComparer&lt;T&gt; implementation to use when 
            comparing elements, or null to use the default implementation.</param>
        </member>
        <member name="M:DotNetXtensions.XArray.SortPair``2(``0[],``1[],System.Int32,System.Int32)">
            <summary>
            Sorts the specified range of this array (<paramref name="baseArray"/>, often called the 
            <i>keys</i> array) while sorting the same range of a paired array 
            (<paramref name="pairedArray"/>, which is often called 
            the <i>items</i> array) in tandem with it.  The <paramref name="baseArray"/> is what 
            determines the sorted order which is sorted by the default IComparable&lt;T&gt; 
            interface.  Both arrays should be of the same length.
            </summary>
            <typeparam name="TBase">The base array type.</typeparam>
            <typeparam name="TPair">The paired array type.</typeparam>
            <param name="baseArray">The base array which determines the sorted 
            order of the pair.</param>
            <param name="pairedArray">The paired array which will be sorted in tandem 
            with <paramref name="baseArray"/>.</param>
            <param name="start">The zero-based starting index of the sort.</param>
            <param name="length">The number of elements to sort following start.</param>
        </member>
        <member name="M:DotNetXtensions.XArray.SortPair``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the specified range of this array (<paramref name="baseArray"/>, often called the 
            <i>keys</i> array) while sorting the same range of a paired array 
            (<paramref name="pairedArray"/>, which is often called 
            the <i>items</i> array) in tandem with it.  The <paramref name="baseArray"/> is what 
            determines the sorted order which is sorted by the specified IComparer&lt;T&gt; 
            interface.  Both arrays should be of the same length.
            </summary>
            <typeparam name="TBase">The base array type.</typeparam>
            <typeparam name="TPair">The paired array type.</typeparam>
            <param name="baseArray">The base array which determines the sorted 
            order of the pair.</param>
            <param name="pairedArray">The paired array which will be sorted in tandem 
            with <paramref name="baseArray"/>.</param>
            <param name="start">The zero-based starting index of the sort.</param>
            <param name="length">The number of elements to sort following start.</param>
            <param name="comparer">The IComparer&lt;T&gt; implementation to use when 
            comparing elements, or null to use the default implementation.</param>
        </member>
        <member name="M:DotNetXtensions.XArray.SortPair(System.Array,System.Array)">
            <summary>
            Sorts this array (<paramref name="baseArray"/>, often called the <i>keys</i> array) 
            while sorting a paired array (<paramref name="pairedArray"/>, which is often called 
            the <i>items</i> array) in tandem with it.  The <paramref name="baseArray"/> is what 
            determines the sorted order which is sorted by the default IComparable
            interface.  Both arrays should be of the same length.
            </summary>
            <param name="baseArray">The base array which determines the sorted 
            order of the pair.</param>
            <param name="pairedArray">The paired array which will be sorted in tandem 
            with <paramref name="baseArray"/>.</param>
        </member>
        <member name="M:DotNetXtensions.XArray.SortPair(System.Array,System.Array,System.Collections.IComparer)">
            <summary>
            Sorts this array (<paramref name="baseArray"/>, often called the <i>keys</i> array) 
            while sorting a paired array (<paramref name="pairedArray"/>, which is often called 
            the <i>items</i> array) in tandem with it.  The <paramref name="baseArray"/> is what 
            determines the sorted order which is sorted by the specified IComparer  
            interface.  Both arrays should be of the same length.
            </summary>
            <param name="baseArray">The base array which determines the sorted 
            order of the pair.</param>
            <param name="pairedArray">The paired array which will be sorted in tandem 
            with <paramref name="baseArray"/>.</param>
            <param name="comparer">The IComparer&lt;T&gt; implementation to use when 
            comparing elements, or null to use the default implementation.</param>
        </member>
        <member name="M:DotNetXtensions.XArray.SortPair(System.Array,System.Array,System.Int32,System.Int32)">
            <summary>
            Sorts the specified range of this array (<paramref name="baseArray"/>, often called the 
            <i>keys</i> array) while sorting the same range of a paired array 
            (<paramref name="pairedArray"/>, which is often called 
            the <i>items</i> array) in tandem with it.  The <paramref name="baseArray"/> is what 
            determines the sorted order which is sorted by the default IComparable 
            interface.  Both arrays should be of the same length.
            </summary>
            <param name="baseArray">The base array which determines the sorted 
            order of the pair.</param>
            <param name="pairedArray">The paired array which will be sorted in tandem 
            with <paramref name="baseArray"/>.</param>
            <param name="start">The zero-based starting index of the sort.</param>
            <param name="length">The number of elements to sort following start.</param>
        </member>
        <member name="M:DotNetXtensions.XArray.SortPair(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
            <summary>
            Sorts the specified range of this array (<paramref name="baseArray"/>, often called the 
            <i>keys</i> array) while sorting the same range of a paired array 
            (<paramref name="pairedArray"/>, which is often called 
            the <i>items</i> array) in tandem with it.  The <paramref name="baseArray"/> is what 
            determines the sorted order which is sorted by the specified IComparer 
            interface.  Both arrays should be of the same length.
            </summary>
            <param name="baseArray">The base array which determines the sorted 
            order of the pair.</param>
            <param name="pairedArray">The paired array which will be sorted in tandem 
            with <paramref name="baseArray"/>.</param>
            <param name="start">The zero-based starting index of the sort.</param>
            <param name="length">The number of elements to sort following start.</param>
            <param name="comparer">The IComparer&lt;T&gt; implementation to use when 
            comparing elements, or null to use the default implementation.</param>
        </member>
        <member name="T:DotNetXtensions.XBase64">
            <summary>
            Extension methods for various conversions.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XBase64.Base64ToUrlSafeBase64(System.String)">
            <summary>
            Converts a Base64 encoded string to a URL safe version of Base64,
            following the same rules followed by Microsoft.IdentityModel.Tokens.Base64UrlEncoder.Encode(): 
            * padding is skipped so the pad character '=' doesn't have to be percent encoded 
            * the 62nd (+) and 63rd ('/') regular base64 encoding characters are replaced
            as follows: '+' with '-', and '/' with '_', as seems to be the standard.
            ---
            Helpful to figuring this out were the contributions on this thread:
            http://stackoverflow.com/questions/26353710/how-to-achieve-base64-url-safe-encoding-in-c
            </summary>
            <param name="b64">Base64</param>
        </member>
        <member name="M:DotNetXtensions.XBase64.UrlSafeBase64ToBase64(System.String)">
            <summary>
            Converts Url safe Base64 back to regular Base64, but in a 
            performant way, namely, because there is only 1 string allocation,
            whereas the other way requires 2 or 3 (3 if '=' padding needed),
            as each string.Replace or concatenation requires another string to be made,
            and the Replace is done in one pass.
            </summary>
            <param name="urlSafeB64">Valid Base64. Nothing is done to validate
            it is valid however.</param>
        </member>
        <member name="T:DotNetXtensions.XByte">
            <summary>
            Extension methods for byte arrays.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XByte.ToHexString(System.Byte[],System.Boolean)">
            <summary>
            Converts the byte array to a hex string very fast. Excellent job
            with code lightly adapted from 'community wiki' here: http://stackoverflow.com/a/14333437/264031
            (the function was originally named: ByteToHexBitFiddle). Now allows a native lowerCase option
            to be input and allows null or empty inputs (null returns null, empty returns empty).
            </summary>
        </member>
        <member name="T:DotNetXtensions.XChar">
            <summary>
            ...
            </summary>
        </member>
        <member name="M:DotNetXtensions.XChar.GetBytes(System.Char)">
            <summary>
            Gets the byte sequence that cooresponds to this character in UTF-8.
            </summary>
            <param name="thisChar">This char.</param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.XChar.GetByteCount(System.Char)">
            <summary>
            Gets the byte count of this character if it were encoded in UTF-8.
            </summary>
            <param name="thisChar">This char.</param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.XChar.GetString(System.Char[],System.Int32,System.Int32)">
            <summary>
            Converts the specified range of this char array to a string and returns the value.
            </summary>
            <param name="chars">These chars.</param>
            <param name="index">The zero based starting index.</param>
            <param name="length">The number of chars following index. </param>
            <returns>The new string.</returns>
        </member>
        <member name="M:DotNetXtensions.XChar.IsAsciiDigit(System.Char)">
            <summary>
            Indicates whether the char is an ascii digit (0-9 only).
            </summary>
        </member>
        <member name="M:DotNetXtensions.XChar.IsAsciiLetter(System.Char)">
            <summary>
            Indicates whether the char is a lowercase ascii letter (a-z only).
            </summary>
        </member>
        <member name="M:DotNetXtensions.XChar.IsAsciiLower(System.Char)">
            <summary>
            Indicates whether the char is a lowercase ascii letter (a-z only).
            </summary>
        </member>
        <member name="M:DotNetXtensions.XChar.IsAsciiUpper(System.Char)">
            <summary>
            Indicates whether the char is an uppercase ascii letter (A-Z only).
            </summary>
        </member>
        <member name="M:DotNetXtensions.XChar.IsAsciiLowerOrDigit(System.Char)">
            <summary>
            Indicates whether the char is a lowercase ascii letter or ascii digit (a-z || 0-9 only).
            </summary>
        </member>
        <member name="M:DotNetXtensions.XChar.IsAsciiUpperOrDigit(System.Char)">
            <summary>
            Indicates whether the char is an uppercase ascii letter or ascii digit (A-Z || 0-9 only).
            </summary>
        </member>
        <member name="M:DotNetXtensions.XChar.IsAsciiLetterOrDigit(System.Char)">
            <summary>
            Indicates whether the char is an ascii letter or ascii digit (a-z || A-Z || 0-9 only).
            </summary>
        </member>
        <member name="M:DotNetXtensions.XChar.IsAsciiAlphaNumeric(System.String,System.Int32)">
            <summary>
            Indicates whether all the characters in this string are ascii letters or numbers (a-z || A-Z || 0-9 only).
            </summary>
        </member>
        <member name="T:DotNetXtensions.XConsole">
            <summary>
            Extension methods for byte arrays.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XConsole.ReadKeySingle(System.Boolean,System.ConsoleKey)">
            <summary>
            Obtains the next character or function key pressed by the user, but validates that 
            only a single character was entered by returning the errorKey value if more than one 
            key was entered. This is done by checking if Console.KeyAvailable is true, and if it is, 
            Console.ReadKey is called repeatedly (which does not prompt the user, so happens immediately,
            which is actually the core problem this function is meant to solve)
            until Console.KeyAvailable is false.
            </summary>
            <param name="intercept">Determines whether to display the pressed key in the console window.
            TRUE to NOT display the pressed key.</param>
            <param name="errorKey">The error key to return if more than one character was entered
            by the prompt after this function calls Console.ReadKey.</param>
        </member>
        <member name="T:DotNetXtensions.XDateTimes">
            <summary>
            Extension methods for DateTimes and TimeSpans.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XDateTimes.Round(System.DateTime,System.TimeSpan)">
            <summary>
            Rounds the DateTime to the nearest specified interval.
            <para/>
            Thanks to DevSal on http://stackoverflow.com/questions/7029353/c-sharp-round-up-time-to-nearest-x-minutes.
            </summary>
            <param name="dt">DateTime to round.</param>
            <param name="roundBy">TimeSpan to round to.</param>
        </member>
        <member name="M:DotNetXtensions.XDateTimes.Round(System.DateTimeOffset,System.TimeSpan)">
            <summary>
            Rounds the DateTimeOffset to the nearest specified interval.
            <para/>
            Thanks to DevSal on http://stackoverflow.com/questions/7029353/c-sharp-round-up-time-to-nearest-x-minutes.
            </summary>
            <param name="dt">DateTime to round.</param>
            <param name="roundBy">TimeSpan to round to.</param>
        </member>
        <member name="M:DotNetXtensions.XDateTimes.JavaUnixTimeToDNetTicks(System.Int64)">
            <summary>
            Converts Java Unix Time (milliseconds since Epoch) to
            .NET ticks (java.util.Date/Calendar, date.getTime()).
            From http://stackoverflow.com/a/29668694/264031
            </summary>
            <param name="value">Java Unix time since Epoch in milliseconds.</param>
        </member>
        <member name="M:DotNetXtensions.XDateTimes.DateTimeStringHasOffset(System.String,System.TimeSpan@)">
            <summary>
            Determines if the input date-time string has a offset value specified,
            either a "Z" zulu ending, indicating UTC, or a plus or minus offset at 
            the end (inclusive of a zero offset, e.g. `+00:00`). 
            Note that NO validation is done on the input string that it is in fact  
            a valid datetime (that is up to the caller), though a quick length range check is performed. 
            The purpose of this function is to answer in the most performant way possible  
            this single question alone. As for the need for this function, see the documetation of
            <see cref="M:DotNetXtensions.XDateTimes.ParseDateTimeWithOffsetInfo(System.String,System.Nullable{System.TimeSpan})"/>, which calls this method.
            </summary>
            <param name="dtStr">DateTime string, which may or may not have an indicated offset.</param>
            <param name="offset">The string based offset</param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.XDateTimes.ParseDateTimeWithOffsetInfo(System.String,System.Nullable{System.TimeSpan})">
            <summary>
            Parses the datetime or datetimeoffset string, while indicating if the original 
            string had an offset. Both a zero offset (+00:00) and a 'Z' ('zulu' time) appendix are considered
            an offset, i.e. an explicit UTC offset indicator. 
            Why is this needed? Because when parsing with DateTimeOffset.Parse, there is no way to know 
            if the string had a offset or not. The problem is, when there is no offset in the string, 
            it is parsed to local (server / computer) time. 
            But in many cases, particularly on the server, you virtually never
            want the server's local time to count for anything, and rather would use another timezone offset
            which you know from context. However, if you simply parse with DateTimeOffset, there is simply
            no way of know if it didn't find an offset, it just makes assumptions! Even if you specify
            the right assumption for it to make, UTC or Local, that's not good enough, you need to know
            if it was neither, in which case you'll be able to, for instance,
            supply your own timezone offset, etc.
            Lastly, one might parse with <see cref="M:System.DateTime.Parse(System.String)"/>, but that makes it's own 
            assumptions as well, again you won't know which was which. Even stranger is the fact, if 
            an offset was indicated, that is *converted* and the time changes accordingly 
            to the stinking local server time. It's understandable, but still frustrating, that
            for instance, indicating UTC time in the string actually makes the final result not UTC! 
            Most importantly though is that you simply have no way of knowing if that conversion was
            silently made. 
            </summary>
            <param name="dateStr">DateTime string</param>
            <param name="addOffsetIfNone">TimeSpan to add, if any, if no offset was indicated.</param>
            <returns>Returns if was success, if offset was indicated, and then for the parsed dtOffset,
            if offsetIndicated or if addOffsetIfNone was not null, returns the expected datetimeoffset with 
            expected offset. Otherwise, the returned value will be the exact time as parsed NOT converted
            to local time, i.e. while we use <see cref="M:System.DateTimeOffset.Parse(System.String)"/>, we in that case
            will return the UtcDateTime of the parsed value.</returns>
        </member>
        <member name="M:DotNetXtensions.XDateTimes.Multiply(System.TimeSpan,System.Int32)">
            <summary>
            Multiplies a timespan by an integer value 
            (source: Stephen Hewlett: http://stackoverflow.com/a/14285561/264031)
            </summary>
        </member>
        <member name="M:DotNetXtensions.XDateTimes.Multiply(System.TimeSpan,System.Double)">
            <summary>
            Multiplies a timespan by a double value
            </summary>
        </member>
        <member name="M:DotNetXtensions.XDateTimes.ToDateTimeOffset(System.DateTime,System.TimeSpan)">
            <summary>
            Converts a DateTime to a DateTimeOffset, without risking any onerous exceptions
            the framework quite unfortunately throws within the DateTimeOffset constructor, 
            such as they do when the source DateTime's Kind is not set to UTC. The best and 
            most performant way around this, which we do herein, is to simply construct the 
            new DateTimeOffset with the overload that excepts Ticks. Also, we will simply 
            return <see cref="F:System.DateTimeOffset.MinValue"/> if the source DateTime was 
            <see cref="F:System.DateTime.MinValue"/>.
            </summary>
            <param name="dt">Source DateTime.</param>
            <param name="offset">Offset</param>
        </member>
        <member name="M:DotNetXtensions.XDateTimes.ToEST(System.DateTimeOffset)">
            <summary>
            Converts the DateTimeOffset to Eastern Standard Time.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XDateTimes.ToEST(System.DateTime)">
            <summary>
            Converts the DateTime to Eastern Standard Time.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XDateTimes.ToDateTimeStringEST(System.DateTime,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Converts the DateTime to Eastern Standard Time.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XDateTimes.ToShortDateString(System.DateTimeOffset)">
            <summary>
            Simply returns dt.ToString("d").
            </summary>
        </member>
        <member name="M:DotNetXtensions.XDateTimes.ToDateTimeString(System.DateTimeOffset,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Displays a nice, human readable time display, and 
            also favoring shorter displays ("Nov" instead of "November"),
            while also allowing a number of options about whether different
            parts of the time should be included in the display
            (e.g. whether to include seconds or not and so forth).
            </summary>
        </member>
        <member name="M:DotNetXtensions.XDateTimes.ToDateTimeString(System.DateTime,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            See overload.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XDateTimes.TimeFromNow(System.DateTime,System.Nullable{System.DateTime})">
            <summary>
            Gets an intelligent, human readable display of how long ago
            the one time is from now, for instance, if its 3 minutes ago, 
            it returns "3 minutes ago" (not 00:00:03.000 for instance).
            This is particularlly useful for many front facing human displays.
            ALPHA, could be worked on further, and, does not yet handle future 
            times.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XDateTimes.ToDateTimeOffset(System.DateTimeOffset,System.TimeZoneInfo,System.Boolean)">
            <summary>
            Generates a new DateTimeOffset which by default (when <paramref name="keepUtcTime" /> 
            is left TRUE) will have the exact same UTC time as the input 
            dt.UtcDateTime value, but with a new Offset derived from the TimeZoneInfo. In other words,
            the 'local' time (dt.DateTime, but please ignore dt.LocalDateTime) is what changes,
            while the UtcDateTime remains the same. Since DateTimeOffset equality is based on UTC, 
            the return value in that case will always be equal to the input value. 
            <para />
            Otherwise, if <paramref name="keepUtcTime" /> is set to false,
            the current time (dt.DateTime) is the value that will remain unchanged 
            while the UtcDateTime is the value that will change.
            </summary>
            <param name="dt">Input DateTimeOffset value.</param>
            <param name="tzInfo">The TimeZoneInfo to get a new Offset from.</param>
            <param name="keepUtcTime">True to keep the same UtcDateTime value 
            (so the DateTime current value will change), 
            false to keep the current DateTime value (the UtcDateTime value will change).</param>
        </member>
        <member name="M:DotNetXtensions.XDateTimes.ToDateTimeOffset(System.DateTimeOffset,System.TimeSpan,System.Boolean)">
            <summary>
            Generates a new DateTimeOffset which by default (when <paramref name="keepUtcTime" /> 
            is left TRUE) will have the exact same UTC time as the input 
            dt.UtcDateTime value, but with a new Offset value. In other words,
            the 'local' time (dt.DateTime, but please ignore dt.LocalDateTime) is what changes,
            while the UtcDateTime remains the same. Since DateTimeOffset equality is based on UTC, 
            the return value in that case will always be equal to the input value. 
            <para />
            Otherwise, if <paramref name="keepUtcTime" /> is set to false,
            the current time (dt.DateTime) is the value that will remain unchanged 
            while the UtcDateTime is the value that will change. This is what
            DateTimeOffset.ToOffset actually does, but unfortunately, the intellisense
            documentation is obscure on this point.
            </summary>
            <param name="dt">Input DateTimeOffset value.</param>
            <param name="offset">The new Offset.</param>
            <param name="keepUtcTime">True to keep the same UtcDateTime value 
            (so the DateTime current value will change), 
            false to keep the current DateTime value (the UtcDateTime value will change).</param>
        </member>
        <member name="M:DotNetXtensions.XDateTimes.ToDateTimeOffset(System.DateTime,System.TimeSpan,System.Boolean)">
            <summary>
            Converts input DateTime to a new DateTimeOffset with the specified Offset value. 
            Importantly, the Kind property on the input DateTime *is ignored* 
            (the frameworks terribly throws an exception if <c>dt.Kind == DateTimeKind.Utc</c>; 
            for purist reasons, but terribly inconvenient).
            Set the <paramref name="isUtc"/> value (default is true) to indicate if the input DateTime is
            already UTC time or if it should be treated as already a local time (any non-UTC time). So if 
            <paramref name="isUtc"/> is false, the returned d.DateTime will equal the input 
            value, else d.UtcDateTime will equal the input value.
            </summary>
            <param name="dt">DateTime</param>
            <param name="offset">Offset</param>
            <param name="isUtc">Indicates if the input DateTime is already a UTC value 
            or else a Local value (any time that is not UTC).</param>
        </member>
        <member name="T:DotNetXtensions.XDictionary">
            <summary>
            Extension methods for Dictionary.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XDictionary.V``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Allows lookup from a Dictionary of the specified value while returning the defaultValue 
            if either the key is null or if the key does not exist in the dictionary.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XDictionary.ValueOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Indirection to V (left as this is a more semantic description still).
            </summary>
        </member>
        <member name="M:DotNetXtensions.XDictionary.ValueN``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Allows lookup of a key value from the input dictionary where the key is of type struct,
            returning NULL if value is not found.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XDictionary.ToDictionary(System.Collections.Specialized.NameValueCollection,System.Boolean,System.Boolean,System.Boolean,System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
            Converts the <see cref="T:System.Collections.Specialized.NameValueCollection"/> into a <see cref="T:System.Collections.Generic.Dictionary`2"/>.
            Keys with more than one value in the original collection only have one value returned
            (whichever is returned by `nvcoll[key]`).
            </summary>
            <param name="nvcoll">NameValueCollection</param>
            <param name="caseSensitive">By default key-names are case-SENSITIVE, set to true for case-insensitivity.
            This setting is ignored if an equalityConverter is sent in.
            For why false by default see 'https://stackoverflow.com/a/24700171/264031'</param>
            <param name="forMultiValuesOnlyGetFirst"></param>
            <param name="trimToNullEmptyOrWhitespaceValues">True to set the value as NULL
            if it was whitespace or empty.</param>
            <param name="equalityComparer">EqualityComparer to send in to determine equality of keys.</param>
        </member>
        <member name="M:DotNetXtensions.XDictionary.ToDictionaryMultiValues(System.Collections.Specialized.NameValueCollection,System.Boolean,System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
            See notes on other, this one returns with multiple values for each key.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XDictionary.ToEnumerable(System.Collections.Specialized.NameValueCollection,System.Boolean)">
            <summary>
            Returns an enumerable <see cref="T:System.Collections.Generic.KeyValuePair`2"/> from the <see cref="T:System.Collections.Specialized.NameValueCollection"/>.
            If the key has multiple values, by default, true to how the NVM works,
            a comma-separated string of all of the values will be set as the value. 
            Or set <paramref name="forMultiValuesOnlyGetFirst"/> to true to only retrieve the 
            first of the values.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XDictionary.ToDictionaryIgnoreDuplicateKeys``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Converts source into a Dictionary, but in the process IGNORES any duplicate key items
            (subsequent items that already match the key are not added).
            After creating the dictionary from source, it is just a regular dictionary, the ignoring
            of the same keys applies only to geration time within this function.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XDictionary.ToDictionaryIgnoreDuplicateKeys``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1},System.Func{System.Tuple{``1,``2,``2},``2})">
            <summary>
            Creates a new Dictionary from source which ignores duplicate keys if they
            already existed (first in wins). To handle the duplicates yourself set 
            <paramref name="handleDuplicate"/>. In that case, 
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TElement"></typeparam>
            <param name="source"></param>
            <param name="keySelector"></param>
            <param name="elementSelector"></param>
            <param name="comparer"></param>
            <param name="handleDuplicate">If not null, this Func will be called when there is a duplicate,
            the return value will be set as the new value. The first TElement in the tuple is the one 
            that was already in the Dictionary.</param>
        </member>
        <member name="M:DotNetXtensions.XDictionary.ToMultiValueDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a new Dictionary whose values are a List of TElement, making it a 'MultiValueDictionary'.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XDictionary.ToMultiValueDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a new Dictionary whose values are a List of TElement, making it a 'MultiValueDictionary'.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XDictionary.ReverseDictionary``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="dict">The source dictionary.</param>
            <param name="ignore">Values to ignore.</param>
            <returns></returns>
        </member>
        <member name="T:DotNetXtensions.XEnum`1">
            <summary>
            Inspired by:
            http://computing-tombarreras.blogspot.com/2009/02/fast-enumeration-to-string-conversion.html
            http://stackoverflow.com/questions/1414277/simple-form-of-array-class-and-enum-getvalues
            https://code.google.com/p/unconstrained-melody/
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:DotNetXtensions.XEnum`1.#cctor">
            <summary>
            STATIC CONSTRUCTOR. Initializes type.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XEnum`1.Value(System.String,System.Nullable{System.Boolean})">
            <summary>
            Get the value from the internal dictionary indexer, so will throw if
            not there. Use the overload where you can enter a default value or else
            use TryGetValue.
            </summary>
            <param name="name">The string name of the value to get.</param>
            <param name="caseInsensitive">If set this value will override the default value
            that has been set for this type: <see cref="P:DotNetXtensions.XEnum`1.CaseInsensitive"/>. From there
            we draw upon either:
            <see cref="F:DotNetXtensions.XEnum`1.m_NamesDictCaseInsens"/> or <see cref="F:DotNetXtensions.XEnum`1.m_NamesDict"/> accordingly.</param>
        </member>
        <member name="T:DotNetXtensions.XLinq">
            <summary>
            Extension methods for Collections.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XLinq.NullIfEmpty``1(``0[])">
            <summary>
            Returns null if source is null or empty, else returns source.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XLinq.NullIfEmpty``1(System.Collections.Generic.List{``0})">
            <summary>
            Returns null if source is null or empty, else returns source.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XLinq.IsNullOrHasNone``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns if source is null or has no items, checked as efficiently as 
            by getting an enumerator and performing a single MoveNext call. This is exactly what Linq.Any 
            (without a parameter) does, but of course it throws an exception for null.
            NOTE: We would have liked to name this Nulle, or IsNulle, but that conflicts with 
            other interfaces and types (List, IList, ICollection, etc) which also implement IEnumerable. 
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.XLinq.E``1(``0)">
            <summary>
            If the object is null, this function will return a new instance of the object 
            (which is possible because this type is constrained by the new() constraint),
            else returns the non-null object immediately.
            </summary>
            <typeparam name="T">Type that has a parameterless constructor.</typeparam>
            <param name="t">Object.</param>
        </member>
        <member name="M:DotNetXtensions.XLinq.E(System.String)">
            <summary>
            Returns an empty string if the string is empty.
            </summary>
            <param name="s">This string.</param>
        </member>
        <member name="M:DotNetXtensions.XLinq.E``1(``0[])">
            <summary>
            If this array is not-null, this function immediately returns it,
            else if the array is NULL it returns an empty T array.
            </summary>
            <typeparam name="T">Type.</typeparam>
            <param name="array">Array.</param>
        </member>
        <member name="M:DotNetXtensions.XLinq.E``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            If this enumerable is not-null, this function immediately returns it,
            else if the enumerable is NULL it returns an empty T array.
            </summary>
            <typeparam name="T">Type.</typeparam>
            <param name="enumerable"></param>
        </member>
        <member name="M:DotNetXtensions.XLinq.ToStringN(System.Object,System.String)">
            <summary>
            Returns ToString on the input object if it is not null, else returns the 
            specified string value.
            value
            </summary>
            <param name="obj">Object.</param>
            <param name="defaultIfNull">Default value to return if obj is null.</param>
        </member>
        <member name="M:DotNetXtensions.XLinq.None``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether a sequence contains no elements or is null
            (this just returns the opposite of Any, but allows a null sequence).
            </summary>
        </member>
        <member name="M:DotNetXtensions.XLinq.None``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Determines whether a sequence contains no elements that match the condition
            (this just returns the opposite of Any, but allows a null sequence).
            </summary>
        </member>
        <member name="M:DotNetXtensions.XLinq.AnySortedCondition``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
            <summary>
            Iterates through the sorted sequence testing each item 
            with the previously gotten item. If <paramref name="predicateCompareLastToCurr"/>
            returns true immediately returns true, else false. This allows one
            to test any condition that can be tested by comparing the last item to current
            in a sorted sequence. For instance, if the sequence was ints, you could verify 
            if any item is ever more than 10 greater than the previous item like follows: 
            <c><paramref name="predicateCompareLastToCurr"/>: (tLast, tCurr) =&gt; (tCurr - tLast) &gt; 10</c>
            One can also test if the sequence has any duplicates for instance if: <c>(tLast, tCurr) =&gt; tCurr == tLast</c>
            </summary>
            <typeparam name="T">T</typeparam>
            <param name="seq">Sequence</param>
            <param name="predicateCompareLastToCurr">Compares the last gotten item with the current
            item.</param>
        </member>
        <member name="M:DotNetXtensions.XLinq.AnySortedDuplicates``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>
            Determines if there are any duplicates in this sorted sequence or if the sequence 
            is not actually sorted, either case of which will immediately return true.
            If it returns false it means every item in the sequence is sequential.
            </summary>
            <typeparam name="T">T</typeparam>
            <param name="seq">Sequence</param>
            <param name="descending">True if the sequence is reverse sorted.</param>
        </member>
        <member name="M:DotNetXtensions.XLinq.IsSorted``1(System.Collections.Generic.IEnumerable{``0},System.Boolean@,System.Boolean)">
            <summary>
            Determines if the sequence is sorted by a single iteration through
            comparing the last item to current item. At the same time it is 
            determined if the sequence had any duplicate items (this value could
            only be correct with our single sequential test if the sequence actually is sorted,
            so if !isSorted, this value will also always be set to true).
            </summary>
            <typeparam name="T">T</typeparam>
            <param name="seq">Sequence</param>
            <param name="anyDuplicates">Any duplicates will be indicated in this
            value IF the sequence was actually sorted.</param>
            <param name="descending">True if checking for descending sort</param>
        </member>
        <member name="M:DotNetXtensions.XLinq.DoIf``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Allows one to conditionally alter the sequence while staying within a LINQ chain.
            If doIf is false, source is immediately returned with no consequence, else source items
            are passed to alterItems which the caller implements. It's possible that code could do nothing
            but immediately return the same source items, but it's there that they would be able to perform
            some LINQ transformation now that the condition was met.
            </summary>
            <typeparam name="TSource">Source type.</typeparam>
            <param name="source">Source items.</param>
            <param name="doIf">True to have the source items transformed via alterItems. False will immediately return source items.</param>
            <param name="alterItems">Gives to caller the source items at this point in the LINQ chain.</param>
        </member>
        <member name="M:DotNetXtensions.XLinq.Distinct``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns distinct elements from a sequence, using the default equality comparer
            *for the given TKey*. What sets DistinctBy apart from LINQ's Distinct is the ability
            to get the key from the object, rather than having to test equality on the object itself.
            Author: Jon Skeet: http://stackoverflow.com/a/489421/264031
            </summary>
            <typeparam name="TSource">Sequence type.</typeparam>
            <typeparam name="TKey">Key type</typeparam>
            <param name="source">Sequence</param>
            <param name="keySelector">Key</param>
        </member>
        <member name="M:DotNetXtensions.XLinq.Distinct``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,System.Collections.Generic.Dictionary{``1,``0},``0})">
            <summary>
            Returns a distinct collection from the input sequence while allowing 
            any duplicate items to first be altered (or filtered still) with <paramref name="handleNonUniqueItem"/>.
            Note that if the return result of <paramref name="handleNonUniqueItem"/> is non-null it will
            be added to the result *even if* the key from the returned item is still a duplicate
            (this is why we pass into <paramref name="handleNonUniqueItem"/> the dictionary of keys already
            found, to allow the consumer to see if the new key they may have generated is itself unique).
            <para/>
            A typical scenario is that <paramref name="handleNonUniqueItem"/> 
            will be used to alter the id or key of the source item. 
            Other useful things can be done with this, such as using  <paramref name="handleNonUniqueItem"/> as a
            means to get ahold of all the items that were duplicates. Even if one still needs 
            to filter those from the return sequence, it could come in handy, such as for
            getting a list of ids that are being (perhaps erroneously) duplicated.
            </summary>
            <typeparam name="TSource">Source type.</typeparam>
            <typeparam name="TKey">Key type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="keySelector">Key selector.</param>
            <param name="handleNonUniqueItem">
            For every item in the source sequence whose key is null or which is a duplicate of a key already encountered,
            this func will be called with input parameters of that item and of the dictionary of key-items that have been
            built up to that point in time of enumerating the source sequence. If the *TSource returned item* 
            is null, it will be filtered from the return sequence, else it will be added to it, even if 
            the new item's key is still a duplicate or null. The returned item's key
            will be added to the dictionary if it is non-null and a duplicate key. 
            </param>
        </member>
        <member name="M:DotNetXtensions.XLinq.Split``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Splits the sequence up into arrays of the specified size.
            Efficiently handles if source is already less than or equal to 
            the split size if sequence is ICollection, in which case 
            <remarks>
            Code influenced by 'SLaks': http://stackoverflow.com/a/5215506/264031
            </remarks>
            </summary>
            <typeparam name="T">T</typeparam>
            <param name="sequence">Input sequence.</param>
            <param name="size">Split size.</param>
        </member>
        <member name="M:DotNetXtensions.XLinq.CountIfCollection``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the count of this IEnumerable if it is in fact an ICollection 
            (generic or regular, which includes Array). Else returns null.  
            </summary>
            <typeparam name="TSource">TSource</typeparam>
            <param name="source">Source</param>
        </member>
        <member name="M:DotNetXtensions.XLinq.CountIfCollection(System.Collections.IEnumerable)">
            <summary>
            Returns the count of this IEnumerable if it is in fact an ICollection 
            (generic or regular, which includes Array). Else returns null.  
            </summary>
            <param name="source">Source</param>
        </member>
        <member name="M:DotNetXtensions.XLinq.Median``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
            <summary>Computes the median of a sequence of items that have an int gotten from the selector.</summary>
        </member>
        <member name="M:DotNetXtensions.XLinq.Median(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Computes the median of a sequence of ints.
            <para/>
            Code transformed from: Richard Carr, http://www.blackwasp.co.uk/LinqMedian_2.aspx
            </summary>
        </member>
        <member name="M:DotNetXtensions.XLinq.AverageOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
            <summary>Computes the average of a sequence of items that have an int gotten from the selector,
            and does NOT throw an exception if the sequence is (null or) empty! </summary>
        </member>
        <member name="M:DotNetXtensions.XLinq.AverageOrDefault(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>Computes the average of the items,
            and does NOT throw an exception if the sequence is (null or) empty!</summary>
        </member>
        <member name="M:DotNetXtensions.XLinq.ConcatToArray``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>
            Joins the two or three sequences into one array, with <paramref name="seq1"/>
            items occuring first and <paramref name="seq2"/> items second, etc.
            </summary>
            <typeparam name="T">The type.</typeparam>
            <param name="seq1">The first sequence.</param>
            <param name="seq2">The second sequence.</param>
            <param name="seq3">A third sequence.</param>
        </member>
        <member name="M:DotNetXtensions.XLinq.FindLastIndex``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Func{``0,System.Boolean})">
            <summary>
            Have not tested this code yet... needs a good test put to it
            </summary>
        </member>
        <member name="M:DotNetXtensions.XLinq.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Gets the minimum item. Source must not be null or empty.
            Inspired by: http://stackoverflow.com/a/914198/264031
            </summary>
        </member>
        <member name="M:DotNetXtensions.XLinq.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Gets the maximum item. Source must not be null or empty.
            </summary>
        </member>
        <member name="T:DotNetXtensions.XList">
            <summary>
            Extension methods for Collections.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XList.E``1(System.Collections.Generic.List{``0})">
            <summary>
            If this list is not-null, this function immediately returns it,
            else if the list is NULL it returns a new (empty) List T.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XList.AddN``2(System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{``0,``1}},``0,``1)">
            <summary>
            Adds KeyValuePair items, without having to generate stinking wordy 'new KeyValuePair TKey, TValue ()'
            </summary>
            <param name="list">List</param>
            <param name="key">Key</param>
            <param name="value">Value</param>
        </member>
        <member name="M:DotNetXtensions.XList.AddN``1(System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{``0,System.String}},``0,System.Object)">
            <summary>
            Adds KeyValuePair items, without having to generate stinking wordy 'new KeyValuePair TKey, TValue ()'
            </summary>
            <param name="list">List</param>
            <param name="key">Key</param>
            <param name="value">Value</param>
        </member>
        <member name="M:DotNetXtensions.XList.AddRange``1(System.Collections.Generic.List{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            AddRange only exists on List (not IList).
            </summary>
        </member>
        <member name="M:DotNetXtensions.XList.InsertN``1(System.Collections.Generic.List{``0},System.Int32,``0)">
            <summary>
            No null exception if list is null, and fixes if index is too high
            out of range (in that case simply adds item, which is fastest anyways).
            </summary>
        </member>
        <member name="T:DotNetXtensions.XML">
            <summary>
            Contains XML type functions and extensions.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XML.ToValidXmlCharactersString(System.String,System.Int32)">
            <summary>
            Determines if any invalid XML 1.0 characters exist within the string, using 
            XML.IsLegalXmlChar method, and if so it returns a new string with the invalid chars removed, 
            else the same string is returned (with no wasted StringBuilder allocated, etc).
            If string is null or empty immediately returns the same value. 
            </summary>
            <param name="s">Xml string.</param>
            <param name="index">The index to begin checking at.</param>
        </member>
        <member name="M:DotNetXtensions.XML.IndexOfFirstInvalidXMLChar(System.String,System.Int32)">
            <summary>
            Gets the index of the first invalid XML 1.0 character in this string, else returns -1.
            </summary>
            <param name="s">Xml string.</param>
            <param name="index">Start index.</param>
        </member>
        <member name="M:DotNetXtensions.XML.IsLegalXmlChar(System.Char)">
            <summary>
            Indicates whether a given character is valid according to the XML 1.0 spec.
            This code represents an optimized version of Tom Bogle's on SO: 
            http://stackoverflow.com/a/13039301/264031.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XML.ToStringIgnoreInvalidChars(System.Xml.Linq.XElement,System.Boolean,System.Boolean,System.Nullable{System.Char})">
            <summary>
            Writes this XML to string while allowing invalid XML chars to either be
            simply removed during the write process, or else encoded into entities, 
            instead of having an exception occur, as the standard XmlWriter.Create 
            XmlWriter does (which is the default writer used by XElement).
            </summary>
            <param name="xml">XElement.</param>
            <param name="deleteInvalidChars">True to have any invalid chars deleted, else they will be entity encoded.</param>
            <param name="indent">Indent setting.</param>
            <param name="indentChar">Indent char (leave null to use default)</param>
        </member>
        <member name="M:DotNetXtensions.XML.GetNamespaceIgnorantXElement(System.String,System.Xml.Linq.LoadOptions)">
            <summary>
            Allows one to serialize an XElement from a XML document that has a
            root xmlns namespace set, but where that root namespace gets highly
            performantly set to empty, which allows one to work with that XElement
            in the simpler, namespace ignorant manner when performant LINQ to XML queries.
            This is done via RootNamespaceIgnorantXmlTextReader, so it is very performant,
            whereas ClearDefaultNamespace must only after serialization traverse every
            element in the document and (when needed) change that elements XName.
            See RootNamespaceIgnorantXmlTextReader documentation for more details.
            </summary>
            <param name="xmlString">String of XML.</param>
            <param name="loadOptions"></param>
        </member>
        <member name="M:DotNetXtensions.XML.GetNamespaceIgnorantXElement(System.Byte[],System.Xml.Linq.LoadOptions)">
            <summary>
            See overload's documentation.
            </summary>
            <param name="xml">XML data.</param>
            <param name="loadOptions"></param>
        </member>
        <member name="M:DotNetXtensions.XML.Serialize``1(``0,System.Boolean)">
            <summary>
            Serializes the object with XmlSerializer, with NO namespaces.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XML.Deserialize``1(System.Xml.Linq.XElement,System.Boolean)">
            <summary>
            Deserializes the object with XmlSerializer, with no namespaces. 
            </summary>
        </member>
        <member name="M:DotNetXtensions.XML.AttributeN(System.Xml.Linq.XName,System.Object)">
            <summary>
            Returns null if <paramref name="value"/> is null,
            else returns a new XAttribute with the value set accordingly.
            This can help in creating much cleaner XML elements
            where conditional attributes are to be only included
            if the value is not null. This way one can do this inline
            within the functional creation of the XElement, rather than 
            having to add these afterwards with if statements. This works
            because null objects that are added to the constructor 
            of an XElement are simply ignored (*thankfully*).
            <code>
            <![CDATA[
            string lastName = null;
            XElement x = new XElement("cool",
            	new XAttribute("firstName", "Joey"),
            	XML.AttributeN("lastName", name)); // will only add a 'lastName' attribute if lastName is not null
            ]]>
            </code>
            </summary>
            <param name="name">XName</param>
            <param name="value">Value. If null, null will be returned.</param>
        </member>
        <member name="M:DotNetXtensions.XML.ElementN(System.Xml.Linq.XName,System.Object)">
            <summary>
            Returns null if <paramref name="value"/> is null,
            else returns a new XElement with the value set accordingly.
            See notes on XML.AttributeN for more information.
            </summary>
            <param name="name">XName</param>
            <param name="value">Value. If null, null will be returned.</param>
        </member>
        <member name="M:DotNetXtensions.XML.SetDefaultNamespace(System.Xml.Linq.XElement,System.Xml.Linq.XNamespace)">
            <summary>
            Sets a default namespace by iterating over all elements (and self)
            and setting the namespace on each one that is empty.
            </summary>
            <param name="elem">Element</param>
            <param name="ns">Namespace</param>
        </member>
        <member name="M:DotNetXtensions.XML.SetDefaultNamespace(System.Xml.Linq.XElement,System.Xml.Linq.XNamespace,System.Boolean)">
            <summary>
            Sets a default namespace by iterating over all elements (and self)
            and setting the namespace on each one that is empty, or on all if
            <paramref name="overwriteAll"/> is true.
            </summary>
            <param name="elem">Element</param>
            <param name="ns">Namespace</param>
            <param name="overwriteAll">True to replace all namespaces.
            Will be a bit more performant as the namespace for each element does
            not have to be compared upon first.</param>
        </member>
        <member name="M:DotNetXtensions.XML.ClearDefaultNamespace(System.Xml.Linq.XElement)">
            <summary>
            If the input XElement has an xmlns namespace value set other than empty ("" - none),
            this function sets that namespace value to "", and then iterates through all
            descendant elements setting their namespace values to empty as well *if* they too
            had the same namespace as the root (input) XElement. The main reason for this
            function is to address one of the worse aspects of XElement -- simply having a
            'xmlns' value set on the root of the document suddenly
            means you always have to specify namespaces when doing LINQ to XML queries, even if
            you only have the one default namespace.
            <para/>
            This function first determines if the namespace on the input XElement is an empty
            namespace (""), and if so, it quickly returns. In those cases where no root xmlns
            namespace is set, this allows one to call this function without a performance hit.
            </summary>
            <param name="elem">XElement</param>
        </member>
        <member name="T:DotNetXtensions.RootNamespaceIgnorantXmlTextReader">
            <summary>
            An XmlTextReader that treats all element namespaces that match the
            root xml's xmlns namespace as an empty string, which in essense then
            acts to set the XML's xmlns as it was empty all along (without, however,
            deleting the root element's xmlns attribute value - when there is one -
            which is not possible with the readonly XmlTextReader).
            <para />
            The reason for making this type was for using it in serializing an
            XElement so as to be able to essentially ignore the root xmlns
            value. Doing that alleviates one of the greatest pains associated with
            the otherwise excellent XElement - being able to easily do LINQ to XML queries
            without messing with namespaces, particularly in those cases where one
            knows that the XML document they are working on simply needed a root xmlns root
            value set.
            <para />
            One must remember to clear the XElement's root xmlns attribute value to empty ("")
            when there is one. And on that note, it should be noted that if any other elements
            in the document had an xmlns value set that is the same as the root value, that
            they would also have to clear those attribute values to empty. Otherwise, those XElements
            will report errors when trying to serialize (call ToString) the XElement. This is however
            a fringe case scenario, as in most cases, the root  namespace will be specified once
            in the root, and not in child elements thereforth.
            <example><code>
            XElement e = XElement.Load(new RootNamespaceIgnorantXmlTextReader(xmlString).Init());
            if (e.Attribute("xmlns") != null)
            	e.Attribute("xmlns").Remove();
            </code></example>
            </summary>
        </member>
        <member name="M:DotNetXtensions.RootNamespaceIgnorantXmlTextReader.Init">
            <summary>
            MUST call this Init method after constructor is called (new object). We
            could not run the following logic in the constructor because it requires calling
            a virtual method in the base class, which is not good, (see why here: https://msdn.microsoft.com/en-us/library/ms182331.aspx)
            ---
            The only need is to record the root Xml xmlns namespace value, if there is one.
            This does require, it must be noted, a call to MoveToContent.
            </summary>
        </member>
        <member name="F:DotNetXtensions.RootNamespaceIgnorantXmlTextReader.m_RootNameSpace">
            <summary>
            Root xmlns namespace if there is one. This will be used
            in our override of NamespaceURI, where we'll return every
            NamespaceURI except those that match this root xmlns value
            (in which case we'll return empty - "").
            </summary>
        </member>
        <member name="F:DotNetXtensions.RootNamespaceIgnorantXmlTextReader.m_NSLen">
            <summary>
            The string length of the final set m_RootNameSpace. Used for faster
            comparisons in NamespaceURI property.
            </summary>
        </member>
        <member name="P:DotNetXtensions.RootNamespaceIgnorantXmlTextReader.NamespaceURI">
            <summary>
            With the root namespace recorded in m_RootNameSpace, we now only have
            to discover if a given element upon which this property is being called
            matches that root namespace. If so, we just return empty (""). ELSE,
            the base.NamespaceURI is simply returned. Comparisons are done extremely
            performantly, so one should notice very little effect from the XmlReader.
            </summary>
        </member>
        <member name="T:DotNetXtensions.XNumeric">
            <summary>
            Extension methods for numbers, math, and related functions.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XNumeric.MinMax(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the input value if it is within the min / max range, else returns
            min if value is below min or the max if value is above max.
            </summary>
            <param name="val">Input value.</param>
            <param name="min">Minimum value that will be returned.</param>
            <param name="max">Maximum value that will be returned.</param>
        </member>
        <member name="M:DotNetXtensions.XNumeric.InRange(System.String,System.Int32,System.Int32)">
            <summary>
            Indicates if the length of this string is in the given range.
            If null returns false.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XNumeric.ToIntFromHex(System.String)">
            <summary>
            Parses this hexadecimal string to its corresponding integer value.
            Leading and trailing white space are ignored.  If the parse fails a 
            FormatException is thrown.
            <example><code>
            <![CDATA[
            // --- Example 1 ---
            int i = 123456;
            
            string hex = i.ToHex();  // hex == 1E240
            int j = hex.ToIntFromHex();  // j == 123456
            
            // --- Example 2 ---
            
            int y = "1E24G".ToIntFromHex();  // ..FormatException..
            // note: "1E24G" is an invalid hex (with "G")
            ]]></code></example>
            </summary>
            <param name="hexString">This hexadecimal string literal.</param>
            <returns>The hexadecimal integer value.</returns>
        </member>
        <member name="M:DotNetXtensions.XNumeric.ToIntFromHex(System.String,System.Nullable{System.Int32})">
            <summary>
            Converts this hexadecimal string to its corresponding integer value.
            Leading and trailing white space are ignored.  If the parse fails, 
            <i>parseFailReturnValue</i> is returned, or -1 if null is entered for that parameter.
            </summary>
            <param name="hexString">This hexadecimal string literal.</param>
            <param name="parseFailReturnValue">The value to return if the parse fails.</param>
            <returns>The hexadecimal integer value or -1.</returns>
        </member>
        <member name="M:DotNetXtensions.XNumeric.ToStringLower(System.Boolean)">
            <summary>
            Converts this boolean to a lower case 'true' / 'false' representation.
            </summary>
            <param name="b">bool</param>
        </member>
        <member name="M:DotNetXtensions.XNumeric.ToStringYesNo(System.Boolean,System.Boolean)">
            <summary>
            Converts this boolean to a 'Yes' / 'No' representation.
            </summary>
            <param name="b">bool</param>
            <param name="lower">True to have a lowercase result returned.</param>
        </member>
        <member name="T:DotNetXtensions.XPrint">
            <summary>
            Extension methods for Collections.
            </summary>
        </member>
        <member name="F:DotNetXtensions.XPrint.Setting_WriteLine_AddExtraLineBreak">
            <summary>
            Print will print an extra line break ("\r\n") if set to true.
            Useful when in some settings, Console.WriteLine isn't printing out
            a line break. For instance, this was true when running unit tests,
            where the result outputted to Output window without a break, 
            for some unknown reason.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XPrint.PrintAndReadKey(System.String)">
            <summary>
            Prints the input string, and then calls Console.ReadKey(true).
            </summary>
            <param name="s">string</param>
        </member>
        <member name="M:DotNetXtensions.XPrint.PrintAndReadKey(System.String,System.Object[])">
            <summary>
            Prints the input objects using the specified format string,
            and then calls Console.ReadKey(true).
            </summary>
            <param name="format">Format string.</param>
            <param name="args">Objects.</param>
        </member>
        <member name="M:DotNetXtensions.XPrint.PrintAndReadSingleKey(System.String,System.ConsoleKey)">
            <summary>
            Prints the input string, and then calls XConsole.ReadKeySingle(true).
            </summary>
            <param name="s">string</param>
            <param name="errorKey"></param>
        </member>
        <member name="M:DotNetXtensions.XPrint.PrintAndReadSingleKey(System.String,System.Object[])">
            <summary>
            Prints the input objects using the specified format string.
            </summary>
            <param name="format">Format string.</param>
            <param name="args">Objects.</param>
        </member>
        <member name="T:DotNetXtensions.XStopwatch">
            <summary>
            Extension methods for Collections.
            </summary>
        </member>
        <member name="T:DotNetXtensions.XStream">
            <summary>
            Extension methods for Streams.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XStream.ReadBytes(System.IO.Stream,System.Int32)">
            <summary>
            Reads the contents of this stream into a byte array reading from the stream's 
            present position by count number of bytes, or less if stream end is reached first.
            This stream does not have to be seekable.
            </summary>
            <param name="stream">This stream.</param>
            <param name="count">The number of bytes to read from stream
            (the number of read bytes will be less if the stream end is reached first).</param>
        </member>
        <member name="M:DotNetXtensions.XStream.__ReadBytes(System.IO.Stream,System.Nullable{System.Int32})">
            <summary>
            Reads the contents of this stream into a byte array reading from the stream's 
            present position by count number of bytes if count is non null (or less if stream 
            end is reached first), or to the stream's end if count is null.
            This stream does not have to be seekable.
            </summary>
            <param name="stream">This stream.</param>
            <param name="count">The number of bytes to read from stream
            (the number of read bytes will be less if the stream end is reached first).
            Enter NULL to specify to read to stream end.</param>
        </member>
        <member name="M:DotNetXtensions.XStream.__WRITE_STREAM_TO_STREAM(System.IO.Stream,System.IO.Stream,System.Nullable{System.Int32})">
            <summary>
            Writes the specified number of bytes from readStream into writeStream, 
            reading and writing (respectively) from each stream's present Position.
            </summary>
            <param name="writeStream">The stream to write to.</param>
            <param name="readStream">The stream to read from.</param>
            <param name="length">The count of bytes to read from readStream
            into writeStream (or less if readStream ends first),
            or NULL to read the entirety of bytes from read stream.</param>
        </member>
        <member name="M:DotNetXtensions.XStream.Read(System.IO.Stream,System.IO.Stream)">
            <summary>
            Reads the entirety of readStream bytes into writeStream, reading and
            writing (respectively) from each stream's present Position.
            </summary>
            <param name="readStream">The stream to read from.</param>
            <param name="writeStream">The stream to write to.</param>
        </member>
        <member name="M:DotNetXtensions.XStream.Read(System.IO.Stream,System.IO.Stream,System.Nullable{System.Int32})">
            <summary>
            Reads the readStream by <paramref name="length"/> number of bytes 
            into writeStream, reading and writing (respectively) from each stream's 
            present Position.
            </summary>
            <param name="readStream">The stream to read from.</param>
            <param name="writeStream">The stream to write to.</param>
            <param name="length">The count of bytes to read from readStream
            into writeStream (or less if readStream ends first),
            or NULL to read the entirety of bytes from read stream.</param>
        </member>
        <member name="M:DotNetXtensions.XStream.Write(System.IO.Stream,System.IO.Stream)">
            <summary>
            Writes the entirety of readStream into writeStream, reading and
            writing (respectively) from each stream's present Position.
            </summary>
            <param name="writeStream">The stream to write to.</param>
            <param name="readStream">The stream to read from.</param>
        </member>
        <member name="M:DotNetXtensions.XStream.Write(System.IO.Stream,System.IO.Stream,System.Int32)">
            <summary>
            Writes the specified number of bytes from readStream into writeStream, 
            reading and writing (respectively) from each stream's present Position.
            </summary>
            <param name="writeStream">The stream to write to.</param>
            <param name="readStream">The stream to read from.</param>
            <param name="length">The count of bytes to read from readStream
            into writeStream (or less if readStream ends first),
            or NULL to read the entirety of bytes from read stream.</param>
        </member>
        <member name="T:DotNetXtensions.XString">
            <summary>
            Extension methods for strings.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XString.All(System.String,System.Int32,System.Func{System.Char,System.Boolean})">
            <summary>
            Determines whether all the chars within the specified range of this string
            (from index to string end) satisfy the given condition.
            </summary>
            <param name="s">This string.</param>
            <param name="index">The start index.</param>
            <param name="predicate">The predicate.</param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.XString.All(System.String,System.Int32,System.Int32,System.Func{System.Char,System.Boolean})">
            <summary>
            Determines whether all the chars within the specified range of this string
            satisfy the given condition.
            </summary>
            <param name="s">This string.</param>
            <param name="index">The start index.</param>
            <param name="length">The length following index.</param>
            <param name="predicate">The predicate.</param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.XString.Any(System.String,System.Int32,System.Func{System.Char,System.Boolean})">
            <summary>
            Determines whether any of the chars within the specified range of this string
            (from index to string end) satisfy the given condition.
            </summary>
            <param name="s">This string.</param>
            <param name="index">The start index.</param>
            <param name="predicate">The predicate.</param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.XString.Any(System.String,System.Int32,System.Int32,System.Func{System.Char,System.Boolean})">
            <summary>
            Determines whether any the chars within the specified range of this string
            satisfy the given condition.
            </summary>
            <param name="s">This string.</param>
            <param name="index">The start index.</param>
            <param name="length">The length following index.</param>
            <param name="predicate">The predicate.</param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.XString.FormatX(System.String,System.Object)">
            <summary>
            Replaces the format items in this string with the text equivalent
            of the values of the cooresponding objects.
            </summary>
            <param name="s">This string.</param>
            <param name="arg0">An object to format.</param>
            <returns>The formatted string.</returns>
        </member>
        <member name="M:DotNetXtensions.XString.FormatX(System.String,System.Object,System.Object)">
             <summary>
             Replaces the format items in this string with the text equivalent
             of the values of the cooresponding objects.
             <example><code>
             <![CDATA[
             string s = "Hi there {0}, you are {1} years old.";
             string person = "Joe";
             int age = 32;
            
             string greeting = s.FormatX(person, age); // == Hi there Joe, you are 32 years old.
             ]]></code></example>
             </summary>
             <param name="s">This string.</param>
             <param name="arg0">An object to format.</param>
             <param name="arg1">An object to format.</param>
             <returns>The formatted string.</returns>
        </member>
        <member name="M:DotNetXtensions.XString.FormatX(System.String,System.Object,System.Object,System.Object)">
            <summary>
            Replaces the format items in this string with the text equivalent
            of the values of the cooresponding objects.
            </summary>
            <param name="s">This string.</param>
            <param name="arg0">An object to format.</param>
            <param name="arg1">An object to format.</param>
            <param name="arg2">An object to format.</param>
            <returns>The formatted string.</returns>
        </member>
        <member name="M:DotNetXtensions.XString.FormatX(System.String,System.Object[])">
            <summary>
            Replaces the format items in this string with the text equivalent
            of the values of the cooresponding objects.
            </summary>
            <param name="s">This string.</param>
            <param name="args">An object array containing zero or more objects to format.</param>
            <returns>The formatted string.</returns>
        </member>
        <member name="M:DotNetXtensions.XString.IsTrimmable(System.String)">
            <summary>
            Indicates if this string can be trimmed. Null and Empty values ARE valid (will return false).
            </summary>
            <param name="s">String</param>
        </member>
        <member name="M:DotNetXtensions.XString.TrimIfNeeded(System.String@)">
            <summary>
            Trims the string only if it is needed. Value CAN be Null or Empty.
            </summary>
            <param name="s">String</param>
        </member>
        <member name="M:DotNetXtensions.XString.TrimIfNeeded(System.String)">
            <summary>
            Trims the string only if it is needed. Value CAN be Null or Empty.
            </summary>
            <param name="s">String</param>
        </member>
        <member name="M:DotNetXtensions.XString.TrimN(System.String)">
            <summary>
            Trims the string if it is not null, else returns null.
            </summary>
            <param name="s">String</param>
        </member>
        <member name="M:DotNetXtensions.XString.GetBytes(System.String)">
            <summary>
            Converts this string into a UTF-8 encoded byte array.
            <example><code>
            <![CDATA[
            byte[] bytes = "Hello World!".GetBytes(); // bytes == 72, 101, 108, ...
            ]]></code></example>
            </summary>
            <param name="s">This string.</param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.XString.GetByteCount(System.String)">
            <summary>
            Returns the number of bytes that would result from encoding this string into
            UTF-8 encoding.
            <example><code>
            <![CDATA[
            int byteCount = "abc".GetByteCount();  // byteCount == 9
            ]]></code></example>
            </summary>
            <param name="s">This string.</param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.XString.__IndexOfAll(System.String,System.String,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Returns the index positions all the occurences of <i>searchValue</i>
            found within the specified range of this string, while employing the specified comparison type,
            or if none is specified, the default StringComparison.CurrentCulture is used (see notes in code
            below: this is the verified default used by String.IndexOf() when no StringComparison is supplied).
            </summary>
            <param name="s">This string.</param>
            <param name="searchValue">The value to search for.</param>
            <param name="index">The start index.</param>
            <param name="length">The number of characters following start index on which to search.</param>
            <param name="comparisonType">A StringComparison value.</param>
            <returns>The index positions of the found values.</returns>
        </member>
        <member name="M:DotNetXtensions.XString.IndexOfAll(System.String,System.String)">
             <summary>
             Returns the index positions all the occurences of <i>searchValue</i>
             found in this string.
             <example><code>
             <![CDATA[
             string text = "How much wood could a wood chuck chuck if a woodchuck could chuck wood?";
            
             int[] finds = text.IndexOfAll("wood");
            
             Console.WriteLine(finds.JoinToString()); // --> 9, 22, 44, 66
            
             // *JoinToString() is a DotNetExtensions extension method.
             ]]></code></example>
             </summary>
             <param name="s">This string.</param>
             <param name="searchValue">The value to search for.</param>
             <returns>The index positions of the found values.</returns>
        </member>
        <member name="M:DotNetXtensions.XString.IndexOfAll(System.String,System.String,System.Int32)">
            <summary>
            Returns the index positions all the occurences of <i>searchValue</i>
            found in this string following index.
            </summary>
            <param name="s">This string.</param>
            <param name="searchValue">The value to search for.</param>
            <param name="index">The start index.</param>
            <returns>The index positions of the found values.</returns>
        </member>
        <member name="M:DotNetXtensions.XString.IndexOfAll(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Returns the index positions all the occurences of <i>searchValue</i>
            found within the specified range of this string.
            </summary>
            <param name="s">This string.</param>
            <param name="searchValue">The value to search for.</param>
            <param name="index">The start index.</param>
            <param name="length">The number of characters following start index on which to search.</param>
            <returns>The index positions of the found values.</returns>
        </member>
        <member name="M:DotNetXtensions.XString.IndexOfAll(System.String,System.String,System.StringComparison)">
            <summary>
            Returns the index positions all the occurences of <i>searchValue</i>
            found in this string, while employing the specified comparison type.
            </summary>
            <param name="s">This string.</param>
            <param name="searchValue">The value to search for.</param>
            <param name="comparisonType">A StringComparison value.</param>
            <returns>The index positions of the found values.</returns>
        </member>
        <member name="M:DotNetXtensions.XString.IndexOfAll(System.String,System.String,System.Int32,System.StringComparison)">
            <summary>
            Returns the index positions all the occurences of <i>searchValue</i>
            found in this string following index, while employing the specified comparison type.
            </summary>
            <param name="s">This string.</param>
            <param name="searchValue">The value to search for.</param>
            <param name="index">The start index.</param>
            <param name="comparisonType">A StringComparison value.</param>
            <returns>The index positions of the found values.</returns>
        </member>
        <member name="M:DotNetXtensions.XString.IndexOfAll(System.String,System.String,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Returns the index positions all the occurences of <i>searchValue</i>
            found within the specified range of this string, while employing the specified comparison type.
            </summary>
            <param name="s">This string.</param>
            <param name="searchValue">The value to search for.</param>
            <param name="index">The start index.</param>
            <param name="length">The number of characters following start index on which to search.</param>
            <param name="comparisonType">A StringComparison value.</param>
            <returns>The index positions of the found values.</returns>
        </member>
        <member name="M:DotNetXtensions.XString.IndexAfter(System.String,System.String,System.Int32)">
            <summary>
            Returns the index *after* the found IndexOf result, or if not found,
            returns -1;
            </summary>
            <param name="s"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.XString.CutEnd(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Cuts the source string by the length of the specified endString.
            By default checks first that the source string does end with that value
            (if not, returns source string). Gracefully ignores any null or empty
            strings (by returning source string), or when end is longer than source (by returning empty).
            </summary>
            <param name="s">Source string.</param>
            <param name="endString">End string expected to occur at end of source string. 
            If not, will return source string.</param>
            <param name="checkDoesEndWith">True (by default) to check the end does actually end
            the source. Specify false to ignore this check if you already know it is a match.</param>
            <param name="ignoreCase">True to have the end check does case-insensitive (OrdinalIgnoreCase).</param>
        </member>
        <member name="M:DotNetXtensions.XString.ToCamelCaseFromCodePascalCase(System.String)">
            <summary>
            By 'CodePascalCase' we mean a code name like this very method's name:
            <see cref="M:DotNetXtensions.XString.ToCamelCaseFromCodePascalCase(System.String)"/>, i.e. a valid C# member name
            whose first letter is capitalized as in the case (typically) of public
            class members. This function assumes the input is valid as such and does nothing
            to verify any of this. It simply lowercases the first char if it determined to 
            already be a lowercase letter, with the additional check first that the string
            must not be null and lenght >= 2 (else returns input string with no error).
            </summary>
            <param name="s">Input string expected to already be a valid code name in PascalCase.</param>
        </member>
        <member name="M:DotNetXtensions.XString.SplitN(System.String,System.Char,System.Nullable{System.Int32},System.Boolean)">
            <summary>
            Calls string.Split, but returns an empty sequence for null or empty input, and assumes
            by default to removeEmptyEntries (default param is true).
            </summary>
            <param name="s">input</param>
            <param name="separator">separator</param>
            <param name="count">Maximum items to return</param>
            <param name="removeEmptyEntries">True (default) to remove nullorempty items.</param>
        </member>
        <member name="M:DotNetXtensions.XString.SplitAndRemoveWhiteSpaceEntries(System.String,System.Char[],System.Predicate{System.String})">
            <summary>
            Trims all entries and removes whitespace entries.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XString.SplitLines(System.String,System.Boolean,System.Boolean)">
            <summary>
            Splits the string into lines, both "\r\n", "\n" are checked.
            Optionally trims the lines and removes empty lines.
            </summary>
            <param name="str"></param>
            <param name="trimLines"></param>
            <param name="removeEmptyLines"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.XString.InsertBreaks(System.String,System.Int32,System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="lengthTillBreak"></param>
            <param name="breakVal">If null, will be set to <see cref="P:System.Environment.NewLine"/>.</param>
            <param name="endWithBreak">True to have the break inserted after the last line.</param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.XString.IsNulle(System.String)">
            <summary>
            Checks if string is null or empty. This is an interesting
            abbreviated form of 'IsNullOrEmpty', which is a char short of half
            the length of the latter. Use it if you want to! Don't if don't. 
            </summary>
            <param name="str">String</param>
        </member>
        <member name="M:DotNetXtensions.XString.NotNulle(System.String)">
            <summary>
            Checks if string is NOT null or empty.
            </summary>
            <param name="str">String</param>
        </member>
        <member name="M:DotNetXtensions.XString.IsNullOrEmpty(System.String)">
            <summary>
            Checks if string is null or empty.
            </summary>
            <param name="str">String</param>
        </member>
        <member name="M:DotNetXtensions.XString.IsNullOrWhiteSpace(System.String)">
            <summary>
            Checks if string is null, empty, or only has whitespace.
            </summary>
            <param name="str">String</param>
        </member>
        <member name="M:DotNetXtensions.XString.EmptyIfNull(System.String)">
            <summary>
            Returns an empty string if input string is null.
            </summary>
            <param name="str">String</param>
        </member>
        <member name="M:DotNetXtensions.XString.NullIfEmpty(System.String)">
            <summary>
            Returns null if input is an empty string, else returns the input.
            </summary>
            <param name="s">String</param>
        </member>
        <member name="M:DotNetXtensions.XString.NullIfEmptyTrimmed(System.String)">
            <summary>
            Returns null if input is an empty or whitespace string, 
            else returns the (trimmed if needed) input.
            </summary>
            <param name="s">String</param>
        </member>
        <member name="M:DotNetXtensions.XString.QQQ(System.String,System.String)">
            <summary>
            If source string is not NULL or EMPTY, source string is returned,
            else the inputed <paramref name="value2"/> string is returned.
            This is a corrolary to the ?? operator, which only checks if
            the first string is null, not if it is also not empty.
            </summary>
            <param name="str">Source string.</param>
            <param name="value2">String to return if source string is NULL or EMPTY.</param>
        </member>
        <member name="M:DotNetXtensions.XString.QQQ(System.String,System.String,System.String)">
            <summary>
            If source string is not NULL or EMPTY, source string is returned,
            else the inputed <paramref name="value2"/> string itself is checked 
            if it is NULL or EMPTY, if so it is returned. Else <paramref name="value3"/>
            is returned.
            </summary>
            <param name="str">Source string.</param>
            <param name="value2">String to return if source string is NULL or EMPTY.</param>
            <param name="value3">String to return if BOTH previous strings were both NULL or EMPTY.</param>
        </member>
        <member name="M:DotNetXtensions.XString.FirstNotNulle(System.String,System.String)">
            <summary>
            If source string is not NULL or EMPTY, source string is returned,
            else the inputed <paramref name="value2"/> string is returned.
            This is a corrolary to the ?? operator, which only checks if
            the first string is null, not if it is also not empty.
            </summary>
            <param name="str">Source string.</param>
            <param name="value2">String to return if source string is NULL or EMPTY.</param>
        </member>
        <member name="M:DotNetXtensions.XString.FirstNotNulle(System.String,System.String,System.String)">
            <summary>
            If source string is not NULL or EMPTY, source string is returned,
            else the inputed <paramref name="value2"/> string itself is checked 
            if it is NULL or EMPTY, if so it is returned. Else <paramref name="value3"/>
            is returned.
            </summary>
            <param name="str">Source string.</param>
            <param name="value2">String to return if source string is NULL or EMPTY.</param>
            <param name="value3">String to return if BOTH previous strings were both NULL or EMPTY.</param>
        </member>
        <member name="M:DotNetXtensions.XString.SubstringMax(System.String,System.Int32,System.Int32,System.String,System.Boolean)">
            <summary>
            Returns a substring of the input string where instead of specifying
            the exact length of the return string (which in .NET's string.Substring
            cannot be specified out of range), one specifies a maxLength, meaning
            maxLength can be out of range, in which case the substring from index
            to the end of the string is returned.
            <para />
            If the string is NULL or EMPTY, the same is immediately returned, NO exceptions
            (Null or OutOfRange) will be thrown.
            <para/>
            This nicely solves the problem when one simply wants the first n length
            of characters from a string, but without having to write a bunch of
            code to make sure they do not go out of range in case, for instance, the string was shorter
            than expected.
            </summary>
            <param name="str">String</param>
            <param name="index">Start Index</param>
            <param name="maxLength">Maximum length of the return substring.</param>
            <param name="ellipsis">...</param>
            <param name="tryBreakOnWord"></param>
        </member>
        <member name="M:DotNetXtensions.XString.SubstringAfterStartsWith(System.String,System.String)">
            <summary>
            Tests if the source string starts with the input <paramref name="startsWithValue"/>,
            in which case returns the remainder of the string after that point. 
            While one could typically just do this: <c>startsWithValue.Substring(str.Length);</c>,
            this method handles testing if source string actually starts with the input value,
            and also gracefully handles null or empty values (for any null or empty input values
            the method returns null).
            </summary>
            <example><c>var val = "bundleId:1234"; var bId = val.SubstringAfter("bundleId:"); // bId == "1234"</c></example>
            <param name="str">Source string, which for a success, should be longer than input value.</param>
            <param name="startsWithValue">The start value.</param>
        </member>
        <member name="M:DotNetXtensions.XString.SubstringAfter(System.String,System.String,System.Boolean)">
            <summary>
            Gets a substring of text following the search value. If not found
            null is returned. An empty string is returned if
            the input string ends with the search val. *Graceful, no exceptions.
            <code>
            "Hello world out there!".SubstringAfter("world ") == "out there!"
            </code>
            </summary>
            <param name="str">String.</param>
            <param name="val">Value to search for.</param>
            <param name="includeSearchVal">True to include the search value in the substring result.</param>
        </member>
        <member name="M:DotNetXtensions.XString.SubstringBefore(System.String,System.String,System.Boolean)">
            <summary>
            Gets a substring of text before the search value. If not found,
            null is returned. An empty string is returned if
            the input string starts with the search val. *Graceful, no exceptions.
            <code>
            "Hello world out there!".SubstringBefore(" world") == "Hello"
            </code>
            </summary>
            <param name="str">String.</param>
            <param name="val">Value to search for.</param>
            <param name="includeSearchVal">True to include the search value in the substring result.</param>
        </member>
        <member name="M:DotNetXtensions.XString.ContainsMax(System.String,System.String,System.Int32,System.Int32,System.Nullable{System.StringComparison})">
            <summary>
            Returns true if the search string occurs *anywhere* within the maximum
            range (see <paramref name="maxCount"/>) from starting point (see <paramref name="startIndex"/>, 
            0 by default). See <see cref="M:DotNetXtensions.XString.IndexOfMax(System.String,System.String,System.Int32,System.Int32,System.Nullable{System.StringComparison})"/> for further
            details.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XString.IndexOfMax(System.String,System.String,System.Int32,System.Int32,System.Nullable{System.StringComparison})">
            <summary>
            Returns the index of search string if it occurs *anywhere* within the maximum
            range (see <paramref name="maxCount"/>) from starting point (see <paramref name="startIndex"/>, 
            0 by default).
            Makes for a much more efficient search, when you want to search from the beginning of a string,
            or from a starting point in the string, where you know you can apply a maximum beyond which 
            the search *should discontinue*. For instance, if you have a long
            text (many paragraphs or more), and you want to know if a certain string exists within just the 
            first 20 characters, this allows you to search only within that range, rather than a full 
            string.Contains search searching the entire string.
            </summary>
            <param name="src"></param>
            <param name="value"></param>
            <param name="maxCount">The maximum count after start index to perform the search.</param>
            <param name="startIndex"></param>
            <param name="comparisonType"></param>
        </member>
        <member name="M:DotNetXtensions.XString.ToLowerN(System.String)">
            <summary>
            Returns string.ToLower, but null if input string is null.
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.XString.ReplaceIfNeeded(System.String,System.String,System.String)">
            <summary>
            Returns a string.Replace result *only* after first validating that at least one instance
            of the specified 'find' string exists in the source string (by means of <see cref="M:System.String.IndexOf(System.String)"/>).
            The benefit to this is, if none exists, the same string is then returned, which means that NO new string
            allocations were ever needed or incurred, but only a single IndexOf operation. This method is useful in
            scenarios where you suspect a majority of times no replacement was needed. Otherwise, it will add a small
            extra overhead of conducting an extra IndexOf operation, so use this accordingly.
            </summary>
            <param name="s">Source string.</param>
            <param name="find">The string to be replaced, if it exists</param>
            <param name="replace">The string to replace the find string with, if it exists</param>
        </member>
        <member name="T:DotNetXtensions.XStringBuilder">
            <summary>
            Extension methods for StringBuilder.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XStringBuilder.TrimEnd(System.Text.StringBuilder)">
            <summary>
            Trims any whitespace from the end of this StringBuilder.
            If no trim is needed, returns almost immediately. Else, the
            operation is highly efficient, only change made is to the Length
            property of the StringBuilder.
            </summary>
        </member>
        <member name="T:DotNetXtensions.XTask">
            <summary>
            Task helpers.
            </summary>
            <remarks>
            *OLD* links (may be helpful still, but not up to date, but I don't want to delete these yet):
            Tutorial:
            http://blogs.msdn.com/b/pfxteam/archive/2012/01/20/10259049.aspx
            http://blogs.msdn.com/b/pfxteam/archive/2012/01/21/10259307.aspx
            http://blogs.msdn.com/b/pfxteam/archive/2012/02/02/10263555.aspx
            
            On old RunSync way (commented out now):
            http://stackoverflow.com/questions/5095183/how-would-i-run-an-async-taskt-method-synchronously
            orig: http://social.msdn.microsoft.com/Forums/en/async/thread/163ef755-ff7b-4ea5-b226-bbe8ef5f4796
            </remarks>
        </member>
        <member name="M:DotNetXtensions.XTask.RunAndForget(System.Func{System.Threading.Tasks.Task})">
            <summary>
            (BETA, Unhappy with confidence level): When Task.Run needs to be 
            used to fire off a task / function and forget about it, this can be
            used as an alternative in that it doesn't give the 4014 warning.
            This simply calls Task.Run(function).ConfigureAwait(continueOnCapturedContext: false);
            
            See discussion here: http://stackoverflow.com/questions/5613951/simplest-way-to-do-a-fire-and-forget-method-in-c-sharp-4-0
            </summary>
            <param name="function"></param>
        </member>
        <member name="M:DotNetXtensions.XTask.TimeoutAfterAsync``1(System.Threading.Tasks.Task{``0},System.TimeSpan)">
            <summary>
            Source: http://stackoverflow.com/a/22078975/264031
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="task"></param>
            <param name="timeout"></param>
        </member>
        <member name="T:DotNetXtensions.XType">
            <summary>
            Extension methods for Types.
            </summary>
        </member>
        <member name="M:DotNetXtensions.XType.GetUnderlyingTypeIfNullable(System.Type)">
            <summary>
            If the input type is a Nullable T, gets the underlying type T.
            Else returns null. This is very performant, taking 0.4 of a microsecond in our tests.
            </summary>
            <param name="type">Type</param>
        </member>
        <member name="M:DotNetXtensions.XType.GetLoadableTypes(System.Reflection.Assembly)">
            <summary>
            From: http://stackoverflow.com/a/29379834/264031
            </summary>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetXtensions.XType.GetTypesImplementingThisInterface(System.Type,System.Reflection.Assembly)">
            <summary>
            Gets types that implement this interface within the input Assembly.
            From: http://stackoverflow.com/a/29379834/264031
            </summary>
            <param name="interfaceType">Interface type, must be an interface.</param>
            <param name="assembly">Assembly</param>
        </member>
        <member name="M:DotNetXtensions.XType.GetTypesImplementingThisInterface(System.Type)">
            <summary>
            Gets types that implement this interface within the assembly in which the type 
            was declared. To get others implemented outside of the declaring assembly see the 
            overload where the Assembly can be passed in.
            </summary>
            <param name="interfaceType">Interface type, must be an interface.</param>
        </member>
    </members>
</doc>
